/* tslint:disable */
/* eslint-disable */
/**
 * ICOREPAY
 * ICOREPAY `Reaper API` documentation
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccountCreateRequestBodyDTO
 */
export interface AccountCreateRequestBodyDTO {
    /**
     * Bank identifier
     * @type {string}
     * @memberof AccountCreateRequestBodyDTO
     */
    'bank': string;
    /**
     * Currency identifier
     * @type {string}
     * @memberof AccountCreateRequestBodyDTO
     */
    'currency': string;
    /**
     * Account deposit enabled
     * @type {boolean}
     * @memberof AccountCreateRequestBodyDTO
     */
    'hasDeposit': boolean;
    /**
     * Account transfer enabled
     * @type {boolean}
     * @memberof AccountCreateRequestBodyDTO
     */
    'hasTransfer': boolean;
    /**
     * 
     * @type {AccountCreateRequestBodyDTOLimits}
     * @memberof AccountCreateRequestBodyDTO
     */
    'limits': AccountCreateRequestBodyDTOLimits;
    /**
     * Type identifier
     * @type {string}
     * @memberof AccountCreateRequestBodyDTO
     */
    'type': string;
    /**
     * AdminUser holder
     * @type {string}
     * @memberof AccountCreateRequestBodyDTO
     */
    'holder': string;
    /**
     * AdminUser holder
     * @type {string}
     * @memberof AccountCreateRequestBodyDTO
     */
    'address': string;
}
/**
 * Account 
 * @export
 * @interface AccountCreateRequestBodyDTOLimits
 */
export interface AccountCreateRequestBodyDTOLimits {
    /**
     * 
     * @type {AccountCreateRequestBodyLimitsDTODeposit}
     * @memberof AccountCreateRequestBodyDTOLimits
     */
    'deposit': AccountCreateRequestBodyLimitsDTODeposit;
    /**
     * 
     * @type {AccountCreateRequestBodyLimitsDTOTransfer}
     * @memberof AccountCreateRequestBodyDTOLimits
     */
    'transfer': AccountCreateRequestBodyLimitsDTOTransfer;
}
/**
 * 
 * @export
 * @interface AccountCreateRequestBodyLimitsDTO
 */
export interface AccountCreateRequestBodyLimitsDTO {
    /**
     * 
     * @type {AccountCreateRequestBodyLimitsDTODeposit}
     * @memberof AccountCreateRequestBodyLimitsDTO
     */
    'deposit': AccountCreateRequestBodyLimitsDTODeposit;
    /**
     * 
     * @type {AccountCreateRequestBodyLimitsDTOTransfer}
     * @memberof AccountCreateRequestBodyLimitsDTO
     */
    'transfer': AccountCreateRequestBodyLimitsDTOTransfer;
}
/**
 * Account deposit limits
 * @export
 * @interface AccountCreateRequestBodyLimitsDTODeposit
 */
export interface AccountCreateRequestBodyLimitsDTODeposit {
    /**
     * Account maximum amount
     * @type {number}
     * @memberof AccountCreateRequestBodyLimitsDTODeposit
     */
    'max': number;
    /**
     * Account minimum amount
     * @type {number}
     * @memberof AccountCreateRequestBodyLimitsDTODeposit
     */
    'min': number;
}
/**
 * Account transfer limits
 * @export
 * @interface AccountCreateRequestBodyLimitsDTOTransfer
 */
export interface AccountCreateRequestBodyLimitsDTOTransfer {
    /**
     * Account maximum amount
     * @type {number}
     * @memberof AccountCreateRequestBodyLimitsDTOTransfer
     */
    'max': number;
    /**
     * Account minimum amount
     * @type {number}
     * @memberof AccountCreateRequestBodyLimitsDTOTransfer
     */
    'min': number;
}
/**
 * 
 * @export
 * @interface AccountCreateRequestBodyLimitsItemDTO
 */
export interface AccountCreateRequestBodyLimitsItemDTO {
    /**
     * Account maximum amount
     * @type {number}
     * @memberof AccountCreateRequestBodyLimitsItemDTO
     */
    'max': number;
    /**
     * Account minimum amount
     * @type {number}
     * @memberof AccountCreateRequestBodyLimitsItemDTO
     */
    'min': number;
}
/**
 * 
 * @export
 * @interface AccountCreateResponseDTO
 */
export interface AccountCreateResponseDTO {
    /**
     * Account creation date
     * @type {string}
     * @memberof AccountCreateResponseDTO
     */
    'createdAt'?: string;
    /**
     * Account identifier
     * @type {string}
     * @memberof AccountCreateResponseDTO
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface AccountGetListResponseDTO
 */
export interface AccountGetListResponseDTO {
    /**
     * AccountGetResponseDTO Total number of items on page
     * @type {number}
     * @memberof AccountGetListResponseDTO
     */
    'count'?: number;
    /**
     * AccountGetResponseDTO Current page number
     * @type {number}
     * @memberof AccountGetListResponseDTO
     */
    'currentPage'?: number;
    /**
     * Array of AccountGetResponseDTO 
     * @type {Set<AccountGetResponseDTO>}
     * @memberof AccountGetListResponseDTO
     */
    'items'?: Set<AccountGetResponseDTO>;
    /**
     * AccountGetResponseDTO Total number of items
     * @type {number}
     * @memberof AccountGetListResponseDTO
     */
    'totalCount'?: number;
    /**
     * AccountGetResponseDTO Total number of pages
     * @type {number}
     * @memberof AccountGetListResponseDTO
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface AccountGetResponseDTO
 */
export interface AccountGetResponseDTO {
    /**
     * Bank identifier
     * @type {string}
     * @memberof AccountGetResponseDTO
     */
    'bank'?: string;
    /**
     * Account creation date
     * @type {string}
     * @memberof AccountGetResponseDTO
     */
    'createdAt'?: string;
    /**
     * Currency identifier
     * @type {string}
     * @memberof AccountGetResponseDTO
     */
    'currency'?: string;
    /**
     * Account deposit enabled
     * @type {boolean}
     * @memberof AccountGetResponseDTO
     */
    'hasDeposit'?: boolean;
    /**
     * Account transfer enabled
     * @type {boolean}
     * @memberof AccountGetResponseDTO
     */
    'hasTransfer'?: boolean;
    /**
     * Account identifier
     * @type {string}
     * @memberof AccountGetResponseDTO
     */
    'id'?: string;
    /**
     * Account key
     * @type {string}
     * @memberof AccountGetResponseDTO
     */
    'key'?: string;
    /**
     * 
     * @type {AccountGetResponseDTOLimits}
     * @memberof AccountGetResponseDTO
     */
    'limits'?: AccountGetResponseDTOLimits;
    /**
     * Account secret
     * @type {string}
     * @memberof AccountGetResponseDTO
     */
    'secret'?: string;
    /**
     * Account status
     * @type {string}
     * @memberof AccountGetResponseDTO
     */
    'status'?: AccountGetResponseDTOStatusEnum;
    /**
     * Type identifier
     * @type {string}
     * @memberof AccountGetResponseDTO
     */
    'type'?: string;
    /**
     * Account last update date
     * @type {string}
     * @memberof AccountGetResponseDTO
     */
    'updatedAt'?: string;
    /**
     * AdminUser holder
     * @type {string}
     * @memberof AccountGetResponseDTO
     */
    'holder'?: string;
    /**
     * AdminUser holder
     * @type {string}
     * @memberof AccountGetResponseDTO
     */
    'address'?: string;
}

export const AccountGetResponseDTOStatusEnum = {
    Active: 'active',
    Blocked: 'blocked',
    Suspended: 'suspended'
} as const;

export type AccountGetResponseDTOStatusEnum = typeof AccountGetResponseDTOStatusEnum[keyof typeof AccountGetResponseDTOStatusEnum];

/**
 * Account 
 * @export
 * @interface AccountGetResponseDTOLimits
 */
export interface AccountGetResponseDTOLimits {
    /**
     * 
     * @type {AccountGetResponseLimitsDTODeposit}
     * @memberof AccountGetResponseDTOLimits
     */
    'deposit'?: AccountGetResponseLimitsDTODeposit;
    /**
     * 
     * @type {AccountGetResponseLimitsDTOTransfer}
     * @memberof AccountGetResponseDTOLimits
     */
    'transfer'?: AccountGetResponseLimitsDTOTransfer;
}
/**
 * 
 * @export
 * @interface AccountGetResponseLimitsDTO
 */
export interface AccountGetResponseLimitsDTO {
    /**
     * 
     * @type {AccountGetResponseLimitsDTODeposit}
     * @memberof AccountGetResponseLimitsDTO
     */
    'deposit'?: AccountGetResponseLimitsDTODeposit;
    /**
     * 
     * @type {AccountGetResponseLimitsDTOTransfer}
     * @memberof AccountGetResponseLimitsDTO
     */
    'transfer'?: AccountGetResponseLimitsDTOTransfer;
}
/**
 * Account deposit limits
 * @export
 * @interface AccountGetResponseLimitsDTODeposit
 */
export interface AccountGetResponseLimitsDTODeposit {
    /**
     * Account maximum amount
     * @type {number}
     * @memberof AccountGetResponseLimitsDTODeposit
     */
    'max'?: number;
    /**
     * Account minimum amount
     * @type {number}
     * @memberof AccountGetResponseLimitsDTODeposit
     */
    'min'?: number;
}
/**
 * Account transfer limits
 * @export
 * @interface AccountGetResponseLimitsDTOTransfer
 */
export interface AccountGetResponseLimitsDTOTransfer {
    /**
     * Account maximum amount
     * @type {number}
     * @memberof AccountGetResponseLimitsDTOTransfer
     */
    'max'?: number;
    /**
     * Account minimum amount
     * @type {number}
     * @memberof AccountGetResponseLimitsDTOTransfer
     */
    'min'?: number;
}
/**
 * 
 * @export
 * @interface AccountGetResponseLimitsItemDTO
 */
export interface AccountGetResponseLimitsItemDTO {
    /**
     * Account maximum amount
     * @type {number}
     * @memberof AccountGetResponseLimitsItemDTO
     */
    'max'?: number;
    /**
     * Account minimum amount
     * @type {number}
     * @memberof AccountGetResponseLimitsItemDTO
     */
    'min'?: number;
}
/**
 * 
 * @export
 * @interface AccountPartialUpdateRequestBodyDTO
 */
export interface AccountPartialUpdateRequestBodyDTO {
    /**
     * Bank identifier
     * @type {string}
     * @memberof AccountPartialUpdateRequestBodyDTO
     */
    'bank'?: string;
    /**
     * Currency identifier
     * @type {string}
     * @memberof AccountPartialUpdateRequestBodyDTO
     */
    'currency'?: string;
    /**
     * Account deposit enabled
     * @type {boolean}
     * @memberof AccountPartialUpdateRequestBodyDTO
     */
    'hasDeposit'?: boolean;
    /**
     * Account transfer enabled
     * @type {boolean}
     * @memberof AccountPartialUpdateRequestBodyDTO
     */
    'hasTransfer'?: boolean;
    /**
     * 
     * @type {AccountPartialUpdateRequestBodyDTOLimits}
     * @memberof AccountPartialUpdateRequestBodyDTO
     */
    'limits'?: AccountPartialUpdateRequestBodyDTOLimits;
    /**
     * Account status
     * @type {string}
     * @memberof AccountPartialUpdateRequestBodyDTO
     */
    'status'?: AccountPartialUpdateRequestBodyDTOStatusEnum;
    /**
     * Type identifier
     * @type {string}
     * @memberof AccountPartialUpdateRequestBodyDTO
     */
    'type'?: string;
    /**
     * AdminUser holder
     * @type {string}
     * @memberof AccountPartialUpdateRequestBodyDTO
     */
    'holder'?: string;
    /**
     * AdminUser holder
     * @type {string}
     * @memberof AccountPartialUpdateRequestBodyDTO
     */
    'address'?: string;
}

export const AccountPartialUpdateRequestBodyDTOStatusEnum = {
    Active: 'active',
    Suspended: 'suspended'
} as const;

export type AccountPartialUpdateRequestBodyDTOStatusEnum = typeof AccountPartialUpdateRequestBodyDTOStatusEnum[keyof typeof AccountPartialUpdateRequestBodyDTOStatusEnum];

/**
 * Account 
 * @export
 * @interface AccountPartialUpdateRequestBodyDTOLimits
 */
export interface AccountPartialUpdateRequestBodyDTOLimits {
    /**
     * 
     * @type {AccountPartialUpdateRequestBodyLimitsDTODeposit}
     * @memberof AccountPartialUpdateRequestBodyDTOLimits
     */
    'deposit'?: AccountPartialUpdateRequestBodyLimitsDTODeposit;
    /**
     * 
     * @type {AccountPartialUpdateRequestBodyLimitsDTOTransfer}
     * @memberof AccountPartialUpdateRequestBodyDTOLimits
     */
    'transfer'?: AccountPartialUpdateRequestBodyLimitsDTOTransfer;
}
/**
 * 
 * @export
 * @interface AccountPartialUpdateRequestBodyLimitsDTO
 */
export interface AccountPartialUpdateRequestBodyLimitsDTO {
    /**
     * 
     * @type {AccountPartialUpdateRequestBodyLimitsDTODeposit}
     * @memberof AccountPartialUpdateRequestBodyLimitsDTO
     */
    'deposit'?: AccountPartialUpdateRequestBodyLimitsDTODeposit;
    /**
     * 
     * @type {AccountPartialUpdateRequestBodyLimitsDTOTransfer}
     * @memberof AccountPartialUpdateRequestBodyLimitsDTO
     */
    'transfer'?: AccountPartialUpdateRequestBodyLimitsDTOTransfer;
}
/**
 * Account deposit limits
 * @export
 * @interface AccountPartialUpdateRequestBodyLimitsDTODeposit
 */
export interface AccountPartialUpdateRequestBodyLimitsDTODeposit {
    /**
     * Account maximum amount
     * @type {number}
     * @memberof AccountPartialUpdateRequestBodyLimitsDTODeposit
     */
    'max'?: number;
    /**
     * Account minimum amount
     * @type {number}
     * @memberof AccountPartialUpdateRequestBodyLimitsDTODeposit
     */
    'min'?: number;
}
/**
 * Account transfer limits
 * @export
 * @interface AccountPartialUpdateRequestBodyLimitsDTOTransfer
 */
export interface AccountPartialUpdateRequestBodyLimitsDTOTransfer {
    /**
     * Account maximum amount
     * @type {number}
     * @memberof AccountPartialUpdateRequestBodyLimitsDTOTransfer
     */
    'max'?: number;
    /**
     * Account minimum amount
     * @type {number}
     * @memberof AccountPartialUpdateRequestBodyLimitsDTOTransfer
     */
    'min'?: number;
}
/**
 * 
 * @export
 * @interface AccountPartialUpdateRequestBodyLimitsItemDTO
 */
export interface AccountPartialUpdateRequestBodyLimitsItemDTO {
    /**
     * Account maximum amount
     * @type {number}
     * @memberof AccountPartialUpdateRequestBodyLimitsItemDTO
     */
    'max'?: number;
    /**
     * Account minimum amount
     * @type {number}
     * @memberof AccountPartialUpdateRequestBodyLimitsItemDTO
     */
    'min'?: number;
}
/**
 * 
 * @export
 * @interface AccountPartialUpdateResponseDTO
 */
export interface AccountPartialUpdateResponseDTO {
    /**
     * Bank identifier
     * @type {string}
     * @memberof AccountPartialUpdateResponseDTO
     */
    'bank'?: string;
    /**
     * Account creation date
     * @type {string}
     * @memberof AccountPartialUpdateResponseDTO
     */
    'createdAt'?: string;
    /**
     * Currency identifier
     * @type {string}
     * @memberof AccountPartialUpdateResponseDTO
     */
    'currency'?: string;
    /**
     * Account deposit enabled
     * @type {boolean}
     * @memberof AccountPartialUpdateResponseDTO
     */
    'hasDeposit'?: boolean;
    /**
     * Account transfer enabled
     * @type {boolean}
     * @memberof AccountPartialUpdateResponseDTO
     */
    'hasTransfer'?: boolean;
    /**
     * Account identifier
     * @type {string}
     * @memberof AccountPartialUpdateResponseDTO
     */
    'id'?: string;
    /**
     * 
     * @type {AccountGetResponseDTOLimits}
     * @memberof AccountPartialUpdateResponseDTO
     */
    'limits'?: AccountGetResponseDTOLimits;
    /**
     * Account status
     * @type {string}
     * @memberof AccountPartialUpdateResponseDTO
     */
    'status'?: AccountPartialUpdateResponseDTOStatusEnum;
    /**
     * Type identifier
     * @type {string}
     * @memberof AccountPartialUpdateResponseDTO
     */
    'type'?: string;
    /**
     * Account last update date
     * @type {string}
     * @memberof AccountPartialUpdateResponseDTO
     */
    'updatedAt'?: string;
    /**
     * AdminUser holder
     * @type {string}
     * @memberof AccountPartialUpdateResponseDTO
     */
    'holder'?: string;
    /**
     * AdminUser holder
     * @type {string}
     * @memberof AccountPartialUpdateResponseDTO
     */
    'address'?: string;
}

export const AccountPartialUpdateResponseDTOStatusEnum = {
    Active: 'active',
    Blocked: 'blocked',
    Suspended: 'suspended'
} as const;

export type AccountPartialUpdateResponseDTOStatusEnum = typeof AccountPartialUpdateResponseDTOStatusEnum[keyof typeof AccountPartialUpdateResponseDTOStatusEnum];

/**
 * 
 * @export
 * @interface AccountStatisticsGetResponseDTO
 */
export interface AccountStatisticsGetResponseDTO {
    /**
     * Statistics sum amount
     * @type {number}
     * @memberof AccountStatisticsGetResponseDTO
     */
    'amount'?: number;
    /**
     * Statistics total conversion
     * @type {number}
     * @memberof AccountStatisticsGetResponseDTO
     */
    'conversion'?: number;
    /**
     * Statistics date
     * @type {string}
     * @memberof AccountStatisticsGetResponseDTO
     */
    'date'?: string;
    /**
     * Statistics successful count
     * @type {number}
     * @memberof AccountStatisticsGetResponseDTO
     */
    'successfullCount'?: number;
    /**
     * Statistics total count
     * @type {number}
     * @memberof AccountStatisticsGetResponseDTO
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface AccountStatisticsGetSimpleListResponseDTO
 */
export interface AccountStatisticsGetSimpleListResponseDTO {
    /**
     * Array of AccountStatisticsGetResponseDTO 
     * @type {Set<AccountStatisticsGetResponseDTO>}
     * @memberof AccountStatisticsGetSimpleListResponseDTO
     */
    'items'?: Set<AccountStatisticsGetResponseDTO>;
    /**
     * AccountStatisticsGetResponseDTO Total number of items
     * @type {number}
     * @memberof AccountStatisticsGetSimpleListResponseDTO
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface AccountUpdateRequestBodyDTO
 */
export interface AccountUpdateRequestBodyDTO {
    /**
     * Bank identifier
     * @type {string}
     * @memberof AccountUpdateRequestBodyDTO
     */
    'bank': string;
    /**
     * Currency identifier
     * @type {string}
     * @memberof AccountUpdateRequestBodyDTO
     */
    'currency': string;
    /**
     * Account deposit enabled
     * @type {boolean}
     * @memberof AccountUpdateRequestBodyDTO
     */
    'hasDeposit': boolean;
    /**
     * Account transfer enabled
     * @type {boolean}
     * @memberof AccountUpdateRequestBodyDTO
     */
    'hasTransfer': boolean;
    /**
     * 
     * @type {AccountUpdateRequestBodyDTOLimits}
     * @memberof AccountUpdateRequestBodyDTO
     */
    'limits': AccountUpdateRequestBodyDTOLimits;
    /**
     * Account status
     * @type {string}
     * @memberof AccountUpdateRequestBodyDTO
     */
    'status': AccountUpdateRequestBodyDTOStatusEnum;
    /**
     * AdminUser holder
     * @type {string}
     * @memberof AccountUpdateRequestBodyDTO
     */
    'holder': string;
    /**
     * AdminUser holder
     * @type {string}
     * @memberof AccountUpdateRequestBodyDTO
     */
    'address': string;
    /**
     * Type identifier
     * @type {string}
     * @memberof AccountUpdateRequestBodyDTO
     */
    'type': string;
}

export const AccountUpdateRequestBodyDTOStatusEnum = {
    Active: 'active',
    Suspended: 'suspended'
} as const;

export type AccountUpdateRequestBodyDTOStatusEnum = typeof AccountUpdateRequestBodyDTOStatusEnum[keyof typeof AccountUpdateRequestBodyDTOStatusEnum];

/**
 * Account 
 * @export
 * @interface AccountUpdateRequestBodyDTOLimits
 */
export interface AccountUpdateRequestBodyDTOLimits {
    /**
     * 
     * @type {AccountUpdateRequestBodyLimitsDTODeposit}
     * @memberof AccountUpdateRequestBodyDTOLimits
     */
    'deposit': AccountUpdateRequestBodyLimitsDTODeposit;
    /**
     * 
     * @type {AccountUpdateRequestBodyLimitsDTOTransfer}
     * @memberof AccountUpdateRequestBodyDTOLimits
     */
    'transfer': AccountUpdateRequestBodyLimitsDTOTransfer;
}
/**
 * 
 * @export
 * @interface AccountUpdateRequestBodyLimitsDTO
 */
export interface AccountUpdateRequestBodyLimitsDTO {
    /**
     * 
     * @type {AccountUpdateRequestBodyLimitsDTODeposit}
     * @memberof AccountUpdateRequestBodyLimitsDTO
     */
    'deposit': AccountUpdateRequestBodyLimitsDTODeposit;
    /**
     * 
     * @type {AccountUpdateRequestBodyLimitsDTOTransfer}
     * @memberof AccountUpdateRequestBodyLimitsDTO
     */
    'transfer': AccountUpdateRequestBodyLimitsDTOTransfer;
}
/**
 * Account deposit limits
 * @export
 * @interface AccountUpdateRequestBodyLimitsDTODeposit
 */
export interface AccountUpdateRequestBodyLimitsDTODeposit {
    /**
     * Account maximum amount
     * @type {number}
     * @memberof AccountUpdateRequestBodyLimitsDTODeposit
     */
    'max': number;
    /**
     * Account minimum amount
     * @type {number}
     * @memberof AccountUpdateRequestBodyLimitsDTODeposit
     */
    'min': number;
}
/**
 * Account transfer limits
 * @export
 * @interface AccountUpdateRequestBodyLimitsDTOTransfer
 */
export interface AccountUpdateRequestBodyLimitsDTOTransfer {
    /**
     * Account maximum amount
     * @type {number}
     * @memberof AccountUpdateRequestBodyLimitsDTOTransfer
     */
    'max': number;
    /**
     * Account minimum amount
     * @type {number}
     * @memberof AccountUpdateRequestBodyLimitsDTOTransfer
     */
    'min': number;
}
/**
 * 
 * @export
 * @interface AccountUpdateRequestBodyLimitsItemDTO
 */
export interface AccountUpdateRequestBodyLimitsItemDTO {
    /**
     * Account maximum amount
     * @type {number}
     * @memberof AccountUpdateRequestBodyLimitsItemDTO
     */
    'max': number;
    /**
     * Account minimum amount
     * @type {number}
     * @memberof AccountUpdateRequestBodyLimitsItemDTO
     */
    'min': number;
}
/**
 * 
 * @export
 * @interface AccountUpdateResponseDTO
 */
export interface AccountUpdateResponseDTO {
    /**
     * Bank identifier
     * @type {string}
     * @memberof AccountUpdateResponseDTO
     */
    'bank'?: string;
    /**
     * Account creation date
     * @type {string}
     * @memberof AccountUpdateResponseDTO
     */
    'createdAt'?: string;
    /**
     * Currency identifier
     * @type {string}
     * @memberof AccountUpdateResponseDTO
     */
    'currency'?: string;
    /**
     * Account deposit enabled
     * @type {boolean}
     * @memberof AccountUpdateResponseDTO
     */
    'hasDeposit'?: boolean;
    /**
     * Account transfer enabled
     * @type {boolean}
     * @memberof AccountUpdateResponseDTO
     */
    'hasTransfer'?: boolean;
    /**
     * Account identifier
     * @type {string}
     * @memberof AccountUpdateResponseDTO
     */
    'id'?: string;
    /**
     * 
     * @type {AccountGetResponseDTOLimits}
     * @memberof AccountUpdateResponseDTO
     */
    'limits'?: AccountGetResponseDTOLimits;
    /**
     * Account status
     * @type {string}
     * @memberof AccountUpdateResponseDTO
     */
    'status'?: AccountUpdateResponseDTOStatusEnum;
    /**
     * Type identifier
     * @type {string}
     * @memberof AccountUpdateResponseDTO
     */
    'type'?: string;
    /**
     * Account last update date
     * @type {string}
     * @memberof AccountUpdateResponseDTO
     */
    'updatedAt'?: string;
    /**
     * AdminUser holder
     * @type {string}
     * @memberof AccountUpdateResponseDTO
     */
    'holder'?: string;
    /**
     * AdminUser holder
     * @type {string}
     * @memberof AccountUpdateResponseDTO
     */
    'address'?: string;
}

export const AccountUpdateResponseDTOStatusEnum = {
    Active: 'active',
    Blocked: 'blocked',
    Suspended: 'suspended'
} as const;

export type AccountUpdateResponseDTOStatusEnum = typeof AccountUpdateResponseDTOStatusEnum[keyof typeof AccountUpdateResponseDTOStatusEnum];

/**
 * 
 * @export
 * @interface AdminAuthAuthenticationRequestBodyDTO
 */
export interface AdminAuthAuthenticationRequestBodyDTO {
    /**
     * AdminUser login
     * @type {string}
     * @memberof AdminAuthAuthenticationRequestBodyDTO
     */
    'login': string;
    /**
     * AdminUser password
     * @type {string}
     * @memberof AdminAuthAuthenticationRequestBodyDTO
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AdminAuthAuthenticationResponseDTO
 */
export interface AdminAuthAuthenticationResponseDTO {
    /**
     * AdminAuth expiration date
     * @type {string}
     * @memberof AdminAuthAuthenticationResponseDTO
     */
    'expiresIn'?: string;
    /**
     * AdminAuth refresh token
     * @type {string}
     * @memberof AdminAuthAuthenticationResponseDTO
     */
    'refreshToken'?: string;
    /**
     * AdminAuth JWT token
     * @type {string}
     * @memberof AdminAuthAuthenticationResponseDTO
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface AdminAuthRefreshRequestBodyDTO
 */
export interface AdminAuthRefreshRequestBodyDTO {
    /**
     * AdminAuth refresh token
     * @type {string}
     * @memberof AdminAuthRefreshRequestBodyDTO
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface AdminAuthRefreshResponseDTO
 */
export interface AdminAuthRefreshResponseDTO {
    /**
     * AdminAuth expiration date
     * @type {string}
     * @memberof AdminAuthRefreshResponseDTO
     */
    'expiresIn'?: string;
    /**
     * AdminAuth refresh token
     * @type {string}
     * @memberof AdminAuthRefreshResponseDTO
     */
    'refreshToken'?: string;
    /**
     * AdminAuth JWT token
     * @type {string}
     * @memberof AdminAuthRefreshResponseDTO
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface AdminUserCreateRequestBodyDTO
 */
export interface AdminUserCreateRequestBodyDTO {
    /**
     * AdminUser login
     * @type {string}
     * @memberof AdminUserCreateRequestBodyDTO
     */
    'login': string;
    /**
     * AdminUser password
     * @type {string}
     * @memberof AdminUserCreateRequestBodyDTO
     */
    'password': string;
    /**
     * AdminUser status
     * @type {string}
     * @memberof AdminUserCreateRequestBodyDTO
     */
    'status': AdminUserCreateRequestBodyDTOStatusEnum;
}

export const AdminUserCreateRequestBodyDTOStatusEnum = {
    Active: 'active',
    Blocked: 'blocked'
} as const;

export type AdminUserCreateRequestBodyDTOStatusEnum = typeof AdminUserCreateRequestBodyDTOStatusEnum[keyof typeof AdminUserCreateRequestBodyDTOStatusEnum];

/**
 * 
 * @export
 * @interface AdminUserCreateResponseDTO
 */
export interface AdminUserCreateResponseDTO {
    /**
     * AdminUser creation date
     * @type {string}
     * @memberof AdminUserCreateResponseDTO
     */
    'createdAt'?: string;
    /**
     * AdminUser identifier
     * @type {string}
     * @memberof AdminUserCreateResponseDTO
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface AdminUserGetListResponseDTO
 */
export interface AdminUserGetListResponseDTO {
    /**
     * AdminUserGetResponseDTO Total number of items on page
     * @type {number}
     * @memberof AdminUserGetListResponseDTO
     */
    'count'?: number;
    /**
     * AdminUserGetResponseDTO Current page number
     * @type {number}
     * @memberof AdminUserGetListResponseDTO
     */
    'currentPage'?: number;
    /**
     * Array of AdminUserGetResponseDTO 
     * @type {Set<AdminUserGetResponseDTO>}
     * @memberof AdminUserGetListResponseDTO
     */
    'items'?: Set<AdminUserGetResponseDTO>;
    /**
     * AdminUserGetResponseDTO Total number of items
     * @type {number}
     * @memberof AdminUserGetListResponseDTO
     */
    'totalCount'?: number;
    /**
     * AdminUserGetResponseDTO Total number of pages
     * @type {number}
     * @memberof AdminUserGetListResponseDTO
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface AdminUserGetResponseDTO
 */
export interface AdminUserGetResponseDTO {
    /**
     * AdminUser creation date
     * @type {string}
     * @memberof AdminUserGetResponseDTO
     */
    'createdAt'?: string;
    /**
     * AdminUser identifier
     * @type {string}
     * @memberof AdminUserGetResponseDTO
     */
    'id'?: string;
    /**
     * AdminUser login
     * @type {string}
     * @memberof AdminUserGetResponseDTO
     */
    'login'?: string;
    /**
     * AdminUser password
     * @type {string}
     * @memberof AdminUserGetResponseDTO
     */
    'password'?: string;
    /**
     * AdminUser last update date
     * @type {string}
     * @memberof AdminUserGetResponseDTO
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface AdminUserPartialUpdateRequestBodyDTO
 */
export interface AdminUserPartialUpdateRequestBodyDTO {
    /**
     * AdminUser login
     * @type {string}
     * @memberof AdminUserPartialUpdateRequestBodyDTO
     */
    'login'?: string;
    /**
     * AdminUser password
     * @type {string}
     * @memberof AdminUserPartialUpdateRequestBodyDTO
     */
    'password'?: string;
    /**
     * AdminUser status
     * @type {string}
     * @memberof AdminUserPartialUpdateRequestBodyDTO
     */
    'status'?: AdminUserPartialUpdateRequestBodyDTOStatusEnum;
}

export const AdminUserPartialUpdateRequestBodyDTOStatusEnum = {
    Active: 'active',
    Blocked: 'blocked'
} as const;

export type AdminUserPartialUpdateRequestBodyDTOStatusEnum = typeof AdminUserPartialUpdateRequestBodyDTOStatusEnum[keyof typeof AdminUserPartialUpdateRequestBodyDTOStatusEnum];

/**
 * 
 * @export
 * @interface AdminUserPartialUpdateResponseDTO
 */
export interface AdminUserPartialUpdateResponseDTO {
    /**
     * AdminUser creation date
     * @type {string}
     * @memberof AdminUserPartialUpdateResponseDTO
     */
    'createdAt'?: string;
    /**
     * AdminUser identifier
     * @type {string}
     * @memberof AdminUserPartialUpdateResponseDTO
     */
    'id'?: string;
    /**
     * AdminUser login
     * @type {string}
     * @memberof AdminUserPartialUpdateResponseDTO
     */
    'login'?: string;
    /**
     * AdminUser password
     * @type {string}
     * @memberof AdminUserPartialUpdateResponseDTO
     */
    'password'?: string;
    /**
     * AdminUser last update date
     * @type {string}
     * @memberof AdminUserPartialUpdateResponseDTO
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface AdminUserUpdateRequestBodyDTO
 */
export interface AdminUserUpdateRequestBodyDTO {
    /**
     * AdminUser login
     * @type {string}
     * @memberof AdminUserUpdateRequestBodyDTO
     */
    'login': string;
    /**
     * AdminUser password
     * @type {string}
     * @memberof AdminUserUpdateRequestBodyDTO
     */
    'password': string;
    /**
     * AdminUser status
     * @type {string}
     * @memberof AdminUserUpdateRequestBodyDTO
     */
    'status': AdminUserUpdateRequestBodyDTOStatusEnum;
}

export const AdminUserUpdateRequestBodyDTOStatusEnum = {
    Active: 'active',
    Blocked: 'blocked'
} as const;

export type AdminUserUpdateRequestBodyDTOStatusEnum = typeof AdminUserUpdateRequestBodyDTOStatusEnum[keyof typeof AdminUserUpdateRequestBodyDTOStatusEnum];

/**
 * 
 * @export
 * @interface AdminUserUpdateResponseDTO
 */
export interface AdminUserUpdateResponseDTO {
    /**
     * AdminUser creation date
     * @type {string}
     * @memberof AdminUserUpdateResponseDTO
     */
    'createdAt'?: string;
    /**
     * AdminUser identifier
     * @type {string}
     * @memberof AdminUserUpdateResponseDTO
     */
    'id'?: string;
    /**
     * AdminUser login
     * @type {string}
     * @memberof AdminUserUpdateResponseDTO
     */
    'login'?: string;
    /**
     * AdminUser password
     * @type {string}
     * @memberof AdminUserUpdateResponseDTO
     */
    'password'?: string;
    /**
     * AdminUser status
     * @type {string}
     * @memberof AdminUserUpdateResponseDTO
     */
    'status'?: AdminUserUpdateResponseDTOStatusEnum;
    /**
     * AdminUser last update date
     * @type {string}
     * @memberof AdminUserUpdateResponseDTO
     */
    'updatedAt'?: string;
}

export const AdminUserUpdateResponseDTOStatusEnum = {
    Active: 'active',
    Blocked: 'blocked'
} as const;

export type AdminUserUpdateResponseDTOStatusEnum = typeof AdminUserUpdateResponseDTOStatusEnum[keyof typeof AdminUserUpdateResponseDTOStatusEnum];

/**
 * 
 * @export
 * @interface AuthAuthenticationResponseDTO
 */
export interface AuthAuthenticationResponseDTO {
    /**
     * Auth expiration date
     * @type {string}
     * @memberof AuthAuthenticationResponseDTO
     */
    'expiresIn'?: string;
    /**
     * Auth refresh token
     * @type {string}
     * @memberof AuthAuthenticationResponseDTO
     */
    'refreshToken'?: string;
    /**
     * Auth JWT token
     * @type {string}
     * @memberof AuthAuthenticationResponseDTO
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface AuthRefreshRequestBodyDTO
 */
export interface AuthRefreshRequestBodyDTO {
    /**
     * Auth refresh token
     * @type {string}
     * @memberof AuthRefreshRequestBodyDTO
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface AuthRefreshResponseDTO
 */
export interface AuthRefreshResponseDTO {
    /**
     * Auth expiration date
     * @type {string}
     * @memberof AuthRefreshResponseDTO
     */
    'expiresIn'?: string;
    /**
     * Auth refresh token
     * @type {string}
     * @memberof AuthRefreshResponseDTO
     */
    'refreshToken'?: string;
    /**
     * Auth JWT token
     * @type {string}
     * @memberof AuthRefreshResponseDTO
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface BadRequestResponseDTO
 */
export interface BadRequestResponseDTO {
    /**
     * Correlation identifier
     * @type {string}
     * @memberof BadRequestResponseDTO
     */
    'correlationID'?: string;
    /**
     * Error name
     * @type {string}
     * @memberof BadRequestResponseDTO
     */
    'error'?: string;
    /**
     * Error message
     * @type {string}
     * @memberof BadRequestResponseDTO
     */
    'message'?: string;
    /**
     * Error status code
     * @type {number}
     * @memberof BadRequestResponseDTO
     */
    'statusCode'?: BadRequestResponseDTOStatusCodeEnum;
    /**
     * Error timestamp
     * @type {number}
     * @memberof BadRequestResponseDTO
     */
    'timestamp'?: number;
}

export const BadRequestResponseDTOStatusCodeEnum = {
    NUMBER_100: 100,
    NUMBER_101: 101,
    NUMBER_102: 102,
    NUMBER_103: 103,
    NUMBER_200: 200,
    NUMBER_201: 201,
    NUMBER_202: 202,
    NUMBER_203: 203,
    NUMBER_204: 204,
    NUMBER_205: 205,
    NUMBER_206: 206,
    NUMBER_207: 207,
    NUMBER_208: 208,
    NUMBER_226: 226,
    NUMBER_300: 300,
    NUMBER_301: 301,
    NUMBER_302: 302,
    NUMBER_303: 303,
    NUMBER_304: 304,
    NUMBER_305: 305,
    NUMBER_306: 306,
    NUMBER_307: 307,
    NUMBER_308: 308,
    NUMBER_400: 400,
    NUMBER_401: 401,
    NUMBER_402: 402,
    NUMBER_403: 403,
    NUMBER_404: 404,
    NUMBER_405: 405,
    NUMBER_406: 406,
    NUMBER_407: 407,
    NUMBER_408: 408,
    NUMBER_409: 409,
    NUMBER_410: 410,
    NUMBER_411: 411,
    NUMBER_412: 412,
    NUMBER_413: 413,
    NUMBER_414: 414,
    NUMBER_415: 415,
    NUMBER_416: 416,
    NUMBER_417: 417,
    NUMBER_418: 418,
    NUMBER_421: 421,
    NUMBER_422: 422,
    NUMBER_423: 423,
    NUMBER_424: 424,
    NUMBER_425: 425,
    NUMBER_426: 426,
    NUMBER_428: 428,
    NUMBER_429: 429,
    NUMBER_431: 431,
    NUMBER_451: 451,
    NUMBER_500: 500,
    NUMBER_501: 501,
    NUMBER_502: 502,
    NUMBER_503: 503,
    NUMBER_504: 504,
    NUMBER_505: 505,
    NUMBER_506: 506,
    NUMBER_507: 507,
    NUMBER_508: 508,
    NUMBER_510: 510,
    NUMBER_511: 511
} as const;

export type BadRequestResponseDTOStatusCodeEnum = typeof BadRequestResponseDTOStatusCodeEnum[keyof typeof BadRequestResponseDTOStatusCodeEnum];

/**
 * 
 * @export
 * @interface BankCreateRequestBodyDTO
 */
export interface BankCreateRequestBodyDTO {
    /**
     * Bank base64 encoded image
     * @type {string}
     * @memberof BankCreateRequestBodyDTO
     */
    'image': string;
    /**
     * Bank message amount pattern
     * @type {string}
     * @memberof BankCreateRequestBodyDTO
     */
    'messageAmountPattern': string;
    /**
     * Bank message content pattern
     * @type {string}
     * @memberof BankCreateRequestBodyDTO
     */
    'messageContentPattern': string;
    /**
     * Bank message amount pattern
     * @type {Set<string>}
     * @memberof BankCreateRequestBodyDTO
     */
    'messageSender': Set<string>;
    /**
     * Bank name
     * @type {string}
     * @memberof BankCreateRequestBodyDTO
     */
    'name': string;
    /**
     * Array of Bank operation mode
     * @type {Set<string>}
     * @memberof BankCreateRequestBodyDTO
     */
    'operationMode': Set<BankCreateRequestBodyDTOOperationModeEnum>;
}

export const BankCreateRequestBodyDTOOperationModeEnum = {
    Push: 'push',
    Sms: 'sms'
} as const;

export type BankCreateRequestBodyDTOOperationModeEnum = typeof BankCreateRequestBodyDTOOperationModeEnum[keyof typeof BankCreateRequestBodyDTOOperationModeEnum];

/**
 * 
 * @export
 * @interface BankCreateResponseDTO
 */
export interface BankCreateResponseDTO {
    /**
     * Bank creation date
     * @type {string}
     * @memberof BankCreateResponseDTO
     */
    'createdAt'?: string;
    /**
     * Bank identifier
     * @type {string}
     * @memberof BankCreateResponseDTO
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface BankGetListResponseDTO
 */
export interface BankGetListResponseDTO {
    /**
     * BankGetResponseDTO Total number of items on page
     * @type {number}
     * @memberof BankGetListResponseDTO
     */
    'count'?: number;
    /**
     * BankGetResponseDTO Current page number
     * @type {number}
     * @memberof BankGetListResponseDTO
     */
    'currentPage'?: number;
    /**
     * Array of BankGetResponseDTO 
     * @type {Set<BankGetResponseDTO>}
     * @memberof BankGetListResponseDTO
     */
    'items'?: Set<BankGetResponseDTO>;
    /**
     * BankGetResponseDTO Total number of items
     * @type {number}
     * @memberof BankGetListResponseDTO
     */
    'totalCount'?: number;
    /**
     * BankGetResponseDTO Total number of pages
     * @type {number}
     * @memberof BankGetListResponseDTO
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface BankGetResponseDTO
 */
export interface BankGetResponseDTO {
    /**
     * Bank creation date
     * @type {string}
     * @memberof BankGetResponseDTO
     */
    'createdAt'?: string;
    /**
     * Bank identifier
     * @type {string}
     * @memberof BankGetResponseDTO
     */
    'id'?: string;
    /**
     * Bank base64 encoded image
     * @type {string}
     * @memberof BankGetResponseDTO
     */
    'image'?: string;
    /**
     * Bank name
     * @type {string}
     * @memberof BankGetResponseDTO
     */
    'name'?: string;
    /**
     * Bank last update date
     * @type {string}
     * @memberof BankGetResponseDTO
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface BankPartialUpdateRequestBodyDTO
 */
export interface BankPartialUpdateRequestBodyDTO {
    /**
     * Bank base64 encoded image
     * @type {string}
     * @memberof BankPartialUpdateRequestBodyDTO
     */
    'image'?: string;
    /**
     * Bank name
     * @type {string}
     * @memberof BankPartialUpdateRequestBodyDTO
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface BankPartialUpdateResponseDTO
 */
export interface BankPartialUpdateResponseDTO {
    /**
     * Bank creation date
     * @type {string}
     * @memberof BankPartialUpdateResponseDTO
     */
    'createdAt'?: string;
    /**
     * Bank identifier
     * @type {string}
     * @memberof BankPartialUpdateResponseDTO
     */
    'id'?: string;
    /**
     * Bank base64 encoded image
     * @type {string}
     * @memberof BankPartialUpdateResponseDTO
     */
    'image'?: string;
    /**
     * Bank 
     * @type {string}
     * @memberof BankPartialUpdateResponseDTO
     */
    'name'?: string;
    /**
     * Bank last update date
     * @type {string}
     * @memberof BankPartialUpdateResponseDTO
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface BankUpdateRequestBodyDTO
 */
export interface BankUpdateRequestBodyDTO {
    /**
     * Bank base64 encoded image
     * @type {string}
     * @memberof BankUpdateRequestBodyDTO
     */
    'image': string;
    /**
     * Bank name
     * @type {string}
     * @memberof BankUpdateRequestBodyDTO
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface BankUpdateResponseDTO
 */
export interface BankUpdateResponseDTO {
    /**
     * Bank creation date
     * @type {string}
     * @memberof BankUpdateResponseDTO
     */
    'createdAt'?: string;
    /**
     * Bank identifier
     * @type {string}
     * @memberof BankUpdateResponseDTO
     */
    'id'?: string;
    /**
     * Bank base64 encoded image
     * @type {string}
     * @memberof BankUpdateResponseDTO
     */
    'image'?: string;
    /**
     * Bank 
     * @type {string}
     * @memberof BankUpdateResponseDTO
     */
    'name'?: string;
    /**
     * Bank last update date
     * @type {string}
     * @memberof BankUpdateResponseDTO
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ConfigSectionCreateRequestBodyDTO
 */
export interface ConfigSectionCreateRequestBodyDTO {
    /**
     * ConfigSection name
     * @type {string}
     * @memberof ConfigSectionCreateRequestBodyDTO
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ConfigSectionCreateResponseDTO
 */
export interface ConfigSectionCreateResponseDTO {
    /**
     * ConfigSection creation date
     * @type {string}
     * @memberof ConfigSectionCreateResponseDTO
     */
    'createdAt'?: string;
    /**
     * ConfigSection identifier
     * @type {string}
     * @memberof ConfigSectionCreateResponseDTO
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface ConfigSectionDataCreateRequestBodyDTO
 */
export interface ConfigSectionDataCreateRequestBodyDTO {
    /**
     * ConfigSectionData key
     * @type {string}
     * @memberof ConfigSectionDataCreateRequestBodyDTO
     */
    'key': string;
    /**
     * ConfigSectionData value
     * @type {string}
     * @memberof ConfigSectionDataCreateRequestBodyDTO
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface ConfigSectionDataCreateResponseDTO
 */
export interface ConfigSectionDataCreateResponseDTO {
    /**
     * ConfigSectionData creation date
     * @type {string}
     * @memberof ConfigSectionDataCreateResponseDTO
     */
    'createdAt'?: string;
    /**
     * ConfigSectionData identifier
     * @type {string}
     * @memberof ConfigSectionDataCreateResponseDTO
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface ConfigSectionDataGetListResponseDTO
 */
export interface ConfigSectionDataGetListResponseDTO {
    /**
     * ConfigSectionDataGetResponseDTO Total number of items on page
     * @type {number}
     * @memberof ConfigSectionDataGetListResponseDTO
     */
    'count'?: number;
    /**
     * ConfigSectionDataGetResponseDTO Current page number
     * @type {number}
     * @memberof ConfigSectionDataGetListResponseDTO
     */
    'currentPage'?: number;
    /**
     * Array of ConfigSectionDataGetResponseDTO 
     * @type {Set<ConfigSectionDataGetResponseDTO>}
     * @memberof ConfigSectionDataGetListResponseDTO
     */
    'items'?: Set<ConfigSectionDataGetResponseDTO>;
    /**
     * ConfigSectionDataGetResponseDTO Total number of items
     * @type {number}
     * @memberof ConfigSectionDataGetListResponseDTO
     */
    'totalCount'?: number;
    /**
     * ConfigSectionDataGetResponseDTO Total number of pages
     * @type {number}
     * @memberof ConfigSectionDataGetListResponseDTO
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface ConfigSectionDataGetResponseDTO
 */
export interface ConfigSectionDataGetResponseDTO {
    /**
     * ConfigSectionData creation date
     * @type {string}
     * @memberof ConfigSectionDataGetResponseDTO
     */
    'createdAt'?: string;
    /**
     * ConfigSectionData identifier
     * @type {string}
     * @memberof ConfigSectionDataGetResponseDTO
     */
    'id'?: string;
    /**
     * ConfigSectionData key
     * @type {string}
     * @memberof ConfigSectionDataGetResponseDTO
     */
    'key'?: string;
    /**
     * ConfigSectionData last update date
     * @type {string}
     * @memberof ConfigSectionDataGetResponseDTO
     */
    'updatedAt'?: string;
    /**
     * ConfigSectionData value
     * @type {string}
     * @memberof ConfigSectionDataGetResponseDTO
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface ConfigSectionDataPartialUpdateRequestBodyDTO
 */
export interface ConfigSectionDataPartialUpdateRequestBodyDTO {
    /**
     * ConfigSectionData key
     * @type {string}
     * @memberof ConfigSectionDataPartialUpdateRequestBodyDTO
     */
    'key'?: string;
    /**
     * ConfigSectionData identifier
     * @type {string}
     * @memberof ConfigSectionDataPartialUpdateRequestBodyDTO
     */
    'section'?: string;
    /**
     * ConfigSectionData value
     * @type {string}
     * @memberof ConfigSectionDataPartialUpdateRequestBodyDTO
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface ConfigSectionDataPartialUpdateResponseDTO
 */
export interface ConfigSectionDataPartialUpdateResponseDTO {
    /**
     * ConfigSectionData creation date
     * @type {string}
     * @memberof ConfigSectionDataPartialUpdateResponseDTO
     */
    'createdAt'?: string;
    /**
     * ConfigSectionData identifier
     * @type {string}
     * @memberof ConfigSectionDataPartialUpdateResponseDTO
     */
    'id'?: string;
    /**
     * ConfigSectionData key
     * @type {string}
     * @memberof ConfigSectionDataPartialUpdateResponseDTO
     */
    'key'?: string;
    /**
     * ConfigSectionData last update date
     * @type {string}
     * @memberof ConfigSectionDataPartialUpdateResponseDTO
     */
    'updatedAt'?: string;
    /**
     * ConfigSectionData value
     * @type {string}
     * @memberof ConfigSectionDataPartialUpdateResponseDTO
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface ConfigSectionDataUpdateRequestBodyDTO
 */
export interface ConfigSectionDataUpdateRequestBodyDTO {
    /**
     * ConfigSectionData key
     * @type {string}
     * @memberof ConfigSectionDataUpdateRequestBodyDTO
     */
    'key': string;
    /**
     * ConfigSectionData identifier
     * @type {string}
     * @memberof ConfigSectionDataUpdateRequestBodyDTO
     */
    'section': string;
    /**
     * ConfigSectionData value
     * @type {string}
     * @memberof ConfigSectionDataUpdateRequestBodyDTO
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface ConfigSectionDataUpdateResponseDTO
 */
export interface ConfigSectionDataUpdateResponseDTO {
    /**
     * ConfigSectionData creation date
     * @type {string}
     * @memberof ConfigSectionDataUpdateResponseDTO
     */
    'createdAt'?: string;
    /**
     * ConfigSectionData identifier
     * @type {string}
     * @memberof ConfigSectionDataUpdateResponseDTO
     */
    'id'?: string;
    /**
     * ConfigSectionData key
     * @type {string}
     * @memberof ConfigSectionDataUpdateResponseDTO
     */
    'key'?: string;
    /**
     * ConfigSectionData last update date
     * @type {string}
     * @memberof ConfigSectionDataUpdateResponseDTO
     */
    'updatedAt'?: string;
    /**
     * ConfigSectionData value
     * @type {string}
     * @memberof ConfigSectionDataUpdateResponseDTO
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface ConfigSectionGetListResponseDTO
 */
export interface ConfigSectionGetListResponseDTO {
    /**
     * ConfigSectionGetResponseDTO Total number of items on page
     * @type {number}
     * @memberof ConfigSectionGetListResponseDTO
     */
    'count'?: number;
    /**
     * ConfigSectionGetResponseDTO Current page number
     * @type {number}
     * @memberof ConfigSectionGetListResponseDTO
     */
    'currentPage'?: number;
    /**
     * Array of ConfigSectionGetResponseDTO 
     * @type {Set<ConfigSectionGetResponseDTO>}
     * @memberof ConfigSectionGetListResponseDTO
     */
    'items'?: Set<ConfigSectionGetResponseDTO>;
    /**
     * ConfigSectionGetResponseDTO Total number of items
     * @type {number}
     * @memberof ConfigSectionGetListResponseDTO
     */
    'totalCount'?: number;
    /**
     * ConfigSectionGetResponseDTO Total number of pages
     * @type {number}
     * @memberof ConfigSectionGetListResponseDTO
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface ConfigSectionGetResponseDTO
 */
export interface ConfigSectionGetResponseDTO {
    /**
     * ConfigSection creation date
     * @type {string}
     * @memberof ConfigSectionGetResponseDTO
     */
    'createdAt'?: string;
    /**
     * ConfigSection identifier
     * @type {string}
     * @memberof ConfigSectionGetResponseDTO
     */
    'id'?: string;
    /**
     * ConfigSection name
     * @type {string}
     * @memberof ConfigSectionGetResponseDTO
     */
    'name'?: string;
    /**
     * ConfigSection last update date
     * @type {string}
     * @memberof ConfigSectionGetResponseDTO
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ConfigSectionUpdateRequestBodyDTO
 */
export interface ConfigSectionUpdateRequestBodyDTO {
    /**
     * ConfigSection name
     * @type {string}
     * @memberof ConfigSectionUpdateRequestBodyDTO
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ConfigSectionUpdateResponseDTO
 */
export interface ConfigSectionUpdateResponseDTO {
    /**
     * ConfigSection creation date
     * @type {string}
     * @memberof ConfigSectionUpdateResponseDTO
     */
    'createdAt'?: string;
    /**
     * ConfigSection identifier
     * @type {string}
     * @memberof ConfigSectionUpdateResponseDTO
     */
    'id'?: string;
    /**
     * ConfigSection name
     * @type {string}
     * @memberof ConfigSectionUpdateResponseDTO
     */
    'name'?: string;
    /**
     * ConfigSection last update date
     * @type {string}
     * @memberof ConfigSectionUpdateResponseDTO
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface CurrencyCreateRequestBodyDTO
 */
export interface CurrencyCreateRequestBodyDTO {
    /**
     * Currency code
     * @type {string}
     * @memberof CurrencyCreateRequestBodyDTO
     */
    'code': string;
    /**
     * Currency precision
     * @type {number}
     * @memberof CurrencyCreateRequestBodyDTO
     */
    'precision': number;
    /**
     * Currency type
     * @type {string}
     * @memberof CurrencyCreateRequestBodyDTO
     */
    'type': CurrencyCreateRequestBodyDTOTypeEnum;
}

export const CurrencyCreateRequestBodyDTOTypeEnum = {
    Crypto: 'crypto',
    Fiat: 'fiat'
} as const;

export type CurrencyCreateRequestBodyDTOTypeEnum = typeof CurrencyCreateRequestBodyDTOTypeEnum[keyof typeof CurrencyCreateRequestBodyDTOTypeEnum];

/**
 * 
 * @export
 * @interface CurrencyCreateResponseDTO
 */
export interface CurrencyCreateResponseDTO {
    /**
     * Currency creation date
     * @type {string}
     * @memberof CurrencyCreateResponseDTO
     */
    'createdAt'?: string;
    /**
     * Currency identifier
     * @type {string}
     * @memberof CurrencyCreateResponseDTO
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface CurrencyGetListResponseDTO
 */
export interface CurrencyGetListResponseDTO {
    /**
     * CurrencyGetResponseDTO Total number of items on page
     * @type {number}
     * @memberof CurrencyGetListResponseDTO
     */
    'count'?: number;
    /**
     * CurrencyGetResponseDTO Current page number
     * @type {number}
     * @memberof CurrencyGetListResponseDTO
     */
    'currentPage'?: number;
    /**
     * Array of CurrencyGetResponseDTO 
     * @type {Set<CurrencyGetResponseDTO>}
     * @memberof CurrencyGetListResponseDTO
     */
    'items'?: Set<CurrencyGetResponseDTO>;
    /**
     * CurrencyGetResponseDTO Total number of items
     * @type {number}
     * @memberof CurrencyGetListResponseDTO
     */
    'totalCount'?: number;
    /**
     * CurrencyGetResponseDTO Total number of pages
     * @type {number}
     * @memberof CurrencyGetListResponseDTO
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface CurrencyGetResponseDTO
 */
export interface CurrencyGetResponseDTO {
    /**
     * Currency 
     * @type {string}
     * @memberof CurrencyGetResponseDTO
     */
    'code'?: string;
    /**
     * Currency creation date
     * @type {string}
     * @memberof CurrencyGetResponseDTO
     */
    'createdAt'?: string;
    /**
     * Currency identifier
     * @type {string}
     * @memberof CurrencyGetResponseDTO
     */
    'id'?: string;
    /**
     * Currency precision
     * @type {number}
     * @memberof CurrencyGetResponseDTO
     */
    'precision'?: number;
    /**
     * Currency type
     * @type {string}
     * @memberof CurrencyGetResponseDTO
     */
    'type'?: CurrencyGetResponseDTOTypeEnum;
    /**
     * Currency last update date
     * @type {string}
     * @memberof CurrencyGetResponseDTO
     */
    'updatedAt'?: string;
}

export const CurrencyGetResponseDTOTypeEnum = {
    Crypto: 'crypto',
    Fiat: 'fiat'
} as const;

export type CurrencyGetResponseDTOTypeEnum = typeof CurrencyGetResponseDTOTypeEnum[keyof typeof CurrencyGetResponseDTOTypeEnum];

/**
 * 
 * @export
 * @interface CurrencyPartialUpdateRequestBodyDTO
 */
export interface CurrencyPartialUpdateRequestBodyDTO {
    /**
     * Currency code
     * @type {string}
     * @memberof CurrencyPartialUpdateRequestBodyDTO
     */
    'code'?: string;
    /**
     * Currency precision
     * @type {number}
     * @memberof CurrencyPartialUpdateRequestBodyDTO
     */
    'precision'?: number;
    /**
     * Currency type
     * @type {string}
     * @memberof CurrencyPartialUpdateRequestBodyDTO
     */
    'type'?: CurrencyPartialUpdateRequestBodyDTOTypeEnum;
}

export const CurrencyPartialUpdateRequestBodyDTOTypeEnum = {
    Crypto: 'crypto',
    Fiat: 'fiat'
} as const;

export type CurrencyPartialUpdateRequestBodyDTOTypeEnum = typeof CurrencyPartialUpdateRequestBodyDTOTypeEnum[keyof typeof CurrencyPartialUpdateRequestBodyDTOTypeEnum];

/**
 * 
 * @export
 * @interface CurrencyPartialUpdateResponseDTO
 */
export interface CurrencyPartialUpdateResponseDTO {
    /**
     * Currency 
     * @type {string}
     * @memberof CurrencyPartialUpdateResponseDTO
     */
    'code'?: string;
    /**
     * Currency creation date
     * @type {string}
     * @memberof CurrencyPartialUpdateResponseDTO
     */
    'createdAt'?: string;
    /**
     * Currency identifier
     * @type {string}
     * @memberof CurrencyPartialUpdateResponseDTO
     */
    'id'?: string;
    /**
     * Currency precision
     * @type {number}
     * @memberof CurrencyPartialUpdateResponseDTO
     */
    'precision'?: number;
    /**
     * Currency type
     * @type {string}
     * @memberof CurrencyPartialUpdateResponseDTO
     */
    'type'?: CurrencyPartialUpdateResponseDTOTypeEnum;
    /**
     * Currency last update date
     * @type {string}
     * @memberof CurrencyPartialUpdateResponseDTO
     */
    'updatedAt'?: string;
}

export const CurrencyPartialUpdateResponseDTOTypeEnum = {
    Crypto: 'crypto',
    Fiat: 'fiat'
} as const;

export type CurrencyPartialUpdateResponseDTOTypeEnum = typeof CurrencyPartialUpdateResponseDTOTypeEnum[keyof typeof CurrencyPartialUpdateResponseDTOTypeEnum];

/**
 * 
 * @export
 * @interface CurrencyUpdateRequestBodyDTO
 */
export interface CurrencyUpdateRequestBodyDTO {
    /**
     * Currency code
     * @type {string}
     * @memberof CurrencyUpdateRequestBodyDTO
     */
    'code': string;
    /**
     * Currency precision
     * @type {number}
     * @memberof CurrencyUpdateRequestBodyDTO
     */
    'precision': number;
    /**
     * Currency type
     * @type {string}
     * @memberof CurrencyUpdateRequestBodyDTO
     */
    'type': CurrencyUpdateRequestBodyDTOTypeEnum;
}

export const CurrencyUpdateRequestBodyDTOTypeEnum = {
    Crypto: 'crypto',
    Fiat: 'fiat'
} as const;

export type CurrencyUpdateRequestBodyDTOTypeEnum = typeof CurrencyUpdateRequestBodyDTOTypeEnum[keyof typeof CurrencyUpdateRequestBodyDTOTypeEnum];

/**
 * 
 * @export
 * @interface CurrencyUpdateResponseDTO
 */
export interface CurrencyUpdateResponseDTO {
    /**
     * Currency 
     * @type {string}
     * @memberof CurrencyUpdateResponseDTO
     */
    'code'?: string;
    /**
     * Currency creation date
     * @type {string}
     * @memberof CurrencyUpdateResponseDTO
     */
    'createdAt'?: string;
    /**
     * Currency identifier
     * @type {string}
     * @memberof CurrencyUpdateResponseDTO
     */
    'id'?: string;
    /**
     * Currency precision
     * @type {number}
     * @memberof CurrencyUpdateResponseDTO
     */
    'precision'?: number;
    /**
     * Currency type
     * @type {string}
     * @memberof CurrencyUpdateResponseDTO
     */
    'type'?: CurrencyUpdateResponseDTOTypeEnum;
    /**
     * Currency last update date
     * @type {string}
     * @memberof CurrencyUpdateResponseDTO
     */
    'updatedAt'?: string;
}

export const CurrencyUpdateResponseDTOTypeEnum = {
    Crypto: 'crypto',
    Fiat: 'fiat'
} as const;

export type CurrencyUpdateResponseDTOTypeEnum = typeof CurrencyUpdateResponseDTOTypeEnum[keyof typeof CurrencyUpdateResponseDTOTypeEnum];

/**
 * 
 * @export
 * @interface DepositCreateRequestBodyDTO
 */
export interface DepositCreateRequestBodyDTO {
    /**
     * Deposit amount
     * @type {number}
     * @memberof DepositCreateRequestBodyDTO
     */
    'amount': number;
    /**
     * Bank identifier
     * @type {string}
     * @memberof DepositCreateRequestBodyDTO
     */
    'bank'?: string;
    /**
     * Currency identifier
     * @type {string}
     * @memberof DepositCreateRequestBodyDTO
     */
    'currency': string;
    /**
     * Deposit customer identifier
     * @type {string}
     * @memberof DepositCreateRequestBodyDTO
     */
    'customerID'?: string;
    /**
     * Deposit internal identifier
     * @type {string}
     * @memberof DepositCreateRequestBodyDTO
     */
    'internalID': string;
    /**
     * Deposit customer IP address
     * @type {string}
     * @memberof DepositCreateRequestBodyDTO
     */
    'ip': string;
    /**
     * Type identifier
     * @type {string}
     * @memberof DepositCreateRequestBodyDTO
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface DepositCreateResponseDTO
 */
export interface DepositCreateResponseDTO {
    /**
     * Deposit creation date
     * @type {string}
     * @memberof DepositCreateResponseDTO
     */
    'createdAt'?: string;
    /**
     * Deposit identifier
     * @type {string}
     * @memberof DepositCreateResponseDTO
     */
    'id'?: string;
    /**
     * Deposit status
     * @type {string}
     * @memberof DepositCreateResponseDTO
     */
    'status'?: DepositCreateResponseDTOStatusEnum;
}

export const DepositCreateResponseDTOStatusEnum = {
    Canceled: 'canceled',
    Expired: 'expired',
    Paid: 'paid',
    Waiting: 'waiting'
} as const;

export type DepositCreateResponseDTOStatusEnum = typeof DepositCreateResponseDTOStatusEnum[keyof typeof DepositCreateResponseDTOStatusEnum];

/**
 * 
 * @export
 * @interface DepositGetListResponseDTO
 */
export interface DepositGetListResponseDTO {
    /**
     * DepositGetResponseDTO Total number of items on page
     * @type {number}
     * @memberof DepositGetListResponseDTO
     */
    'count'?: number;
    /**
     * DepositGetResponseDTO Current page number
     * @type {number}
     * @memberof DepositGetListResponseDTO
     */
    'currentPage'?: number;
    /**
     * Array of DepositGetResponseDTO 
     * @type {Set<DepositGetResponseDTO>}
     * @memberof DepositGetListResponseDTO
     */
    'items'?: Set<DepositGetResponseDTO>;
    /**
     * DepositGetResponseDTO Total number of items
     * @type {number}
     * @memberof DepositGetListResponseDTO
     */
    'totalCount'?: number;
    /**
     * DepositGetResponseDTO Total number of pages
     * @type {number}
     * @memberof DepositGetListResponseDTO
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface DepositGetResponseAccountDTO
 */
export interface DepositGetResponseAccountDTO {
    /**
     * Account identifier
     * @type {string}
     * @memberof DepositGetResponseAccountDTO
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface DepositGetResponseCurrencyDTO
 */
export interface DepositGetResponseCurrencyDTO {
    /**
     * Currency identifier
     * @type {string}
     * @memberof DepositGetResponseCurrencyDTO
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface DepositGetResponseDTO
 */
export interface DepositGetResponseDTO {
    /**
     * 
     * @type {DepositGetResponseDTOAccount}
     * @memberof DepositGetResponseDTO
     */
    'account'?: DepositGetResponseDTOAccount;
    /**
     * Deposit amount
     * @type {number}
     * @memberof DepositGetResponseDTO
     */
    'amount'?: number;
    /**
     * Deposit creation date
     * @type {string}
     * @memberof DepositGetResponseDTO
     */
    'createdAt'?: string;
    /**
     * 
     * @type {DepositGetResponseDTOCurrency}
     * @memberof DepositGetResponseDTO
     */
    'currency'?: DepositGetResponseDTOCurrency;
    /**
     * Deposit expiration date
     * @type {string}
     * @memberof DepositGetResponseDTO
     */
    'expiresIn'?: string;
    /**
     * 
     * @type {DepositGetResponseDTOFee}
     * @memberof DepositGetResponseDTO
     */
    'fee'?: DepositGetResponseDTOFee;
    /**
     * Deposit identifier
     * @type {string}
     * @memberof DepositGetResponseDTO
     */
    'id'?: string;
    /**
     * Deposit status
     * @type {string}
     * @memberof DepositGetResponseDTO
     */
    'status'?: DepositGetResponseDTOStatusEnum;
    /**
     * 
     * @type {DepositGetResponseDTOType}
     * @memberof DepositGetResponseDTO
     */
    'type'?: DepositGetResponseDTOType;
    /**
     * Deposit last update date
     * @type {string}
     * @memberof DepositGetResponseDTO
     */
    'updatedAt'?: string;
}

export const DepositGetResponseDTOStatusEnum = {
    Canceled: 'canceled',
    Expired: 'expired',
    Paid: 'paid',
    Waiting: 'waiting'
} as const;

export type DepositGetResponseDTOStatusEnum = typeof DepositGetResponseDTOStatusEnum[keyof typeof DepositGetResponseDTOStatusEnum];

/**
 * Deposit account
 * @export
 * @interface DepositGetResponseDTOAccount
 */
export interface DepositGetResponseDTOAccount {
    /**
     * Account identifier
     * @type {string}
     * @memberof DepositGetResponseDTOAccount
     */
    'id'?: string;
}
/**
 * Deposit currency
 * @export
 * @interface DepositGetResponseDTOCurrency
 */
export interface DepositGetResponseDTOCurrency {
    /**
     * Currency identifier
     * @type {string}
     * @memberof DepositGetResponseDTOCurrency
     */
    'id'?: string;
}
/**
 * Deposit fee
 * @export
 * @interface DepositGetResponseDTOFee
 */
export interface DepositGetResponseDTOFee {
    /**
     * Deposit fee ratio
     * @type {number}
     * @memberof DepositGetResponseDTOFee
     */
    'depositRatio'?: number;
    /**
     * Deposit fee value
     * @type {number}
     * @memberof DepositGetResponseDTOFee
     */
    'internal'?: number;
}
/**
 * Deposit type
 * @export
 * @interface DepositGetResponseDTOType
 */
export interface DepositGetResponseDTOType {
    /**
     * Type identifier
     * @type {string}
     * @memberof DepositGetResponseDTOType
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface DepositGetResponseFeeDTO
 */
export interface DepositGetResponseFeeDTO {
    /**
     * Deposit fee ratio
     * @type {number}
     * @memberof DepositGetResponseFeeDTO
     */
    'depositRatio'?: number;
    /**
     * Deposit fee value
     * @type {number}
     * @memberof DepositGetResponseFeeDTO
     */
    'internal'?: number;
}
/**
 * 
 * @export
 * @interface DepositGetResponseTypeDTO
 */
export interface DepositGetResponseTypeDTO {
    /**
     * Type identifier
     * @type {string}
     * @memberof DepositGetResponseTypeDTO
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface InfoHealthControllerCheck503Response
 */
export interface InfoHealthControllerCheck503Response {
    /**
     * 
     * @type {string}
     * @memberof InfoHealthControllerCheck503Response
     */
    'status'?: string;
    /**
     * 
     * @type {{ [key: string]: InfoHealthControllerCheck503ResponseInfoValue; }}
     * @memberof InfoHealthControllerCheck503Response
     */
    'info'?: { [key: string]: InfoHealthControllerCheck503ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: InfoHealthControllerCheck503ResponseInfoValue; }}
     * @memberof InfoHealthControllerCheck503Response
     */
    'error'?: { [key: string]: InfoHealthControllerCheck503ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: InfoHealthControllerCheck503ResponseInfoValue; }}
     * @memberof InfoHealthControllerCheck503Response
     */
    'details'?: { [key: string]: InfoHealthControllerCheck503ResponseInfoValue; };
}
/**
 * 
 * @export
 * @interface InfoHealthControllerCheck503ResponseInfoValue
 */
export interface InfoHealthControllerCheck503ResponseInfoValue {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof InfoHealthControllerCheck503ResponseInfoValue
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface InfoHealthGettingResponseDTO
 */
export interface InfoHealthGettingResponseDTO {
    /**
     * 
     * @type {InfoHealthGettingResponseDTODetails}
     * @memberof InfoHealthGettingResponseDTO
     */
    'details'?: InfoHealthGettingResponseDTODetails;
    /**
     * 
     * @type {InfoHealthGettingResponseDTOError}
     * @memberof InfoHealthGettingResponseDTO
     */
    'error'?: InfoHealthGettingResponseDTOError;
    /**
     * 
     * @type {InfoHealthGettingResponseDTOInfo}
     * @memberof InfoHealthGettingResponseDTO
     */
    'info'?: InfoHealthGettingResponseDTOInfo;
    /**
     * Health status
     * @type {string}
     * @memberof InfoHealthGettingResponseDTO
     */
    'status'?: InfoHealthGettingResponseDTOStatusEnum;
    /**
     * Health response timestamp
     * @type {number}
     * @memberof InfoHealthGettingResponseDTO
     */
    'timestamp'?: number;
}

export const InfoHealthGettingResponseDTOStatusEnum = {
    Error: 'error',
    Ok: 'ok'
} as const;

export type InfoHealthGettingResponseDTOStatusEnum = typeof InfoHealthGettingResponseDTOStatusEnum[keyof typeof InfoHealthGettingResponseDTOStatusEnum];

/**
 * Health details
 * @export
 * @interface InfoHealthGettingResponseDTODetails
 */
export interface InfoHealthGettingResponseDTODetails {
    /**
     * 
     * @type {InfoHealthGettingResponseInfoDTOApplication}
     * @memberof InfoHealthGettingResponseDTODetails
     */
    'application'?: InfoHealthGettingResponseInfoDTOApplication;
    /**
     * 
     * @type {InfoHealthGettingResponseInfoDTOMemoryHeap}
     * @memberof InfoHealthGettingResponseDTODetails
     */
    'memory_heap'?: InfoHealthGettingResponseInfoDTOMemoryHeap;
}
/**
 * Health error
 * @export
 * @interface InfoHealthGettingResponseDTOError
 */
export interface InfoHealthGettingResponseDTOError {
    /**
     * 
     * @type {InfoHealthGettingResponseInfoDTOApplication}
     * @memberof InfoHealthGettingResponseDTOError
     */
    'application'?: InfoHealthGettingResponseInfoDTOApplication;
    /**
     * 
     * @type {InfoHealthGettingResponseInfoDTOMemoryHeap}
     * @memberof InfoHealthGettingResponseDTOError
     */
    'memory_heap'?: InfoHealthGettingResponseInfoDTOMemoryHeap;
}
/**
 * Health info
 * @export
 * @interface InfoHealthGettingResponseDTOInfo
 */
export interface InfoHealthGettingResponseDTOInfo {
    /**
     * 
     * @type {InfoHealthGettingResponseInfoDTOApplication}
     * @memberof InfoHealthGettingResponseDTOInfo
     */
    'application'?: InfoHealthGettingResponseInfoDTOApplication;
    /**
     * 
     * @type {InfoHealthGettingResponseInfoDTOMemoryHeap}
     * @memberof InfoHealthGettingResponseDTOInfo
     */
    'memory_heap'?: InfoHealthGettingResponseInfoDTOMemoryHeap;
}
/**
 * 
 * @export
 * @interface InfoHealthGettingResponseInfoDTO
 */
export interface InfoHealthGettingResponseInfoDTO {
    /**
     * 
     * @type {InfoHealthGettingResponseInfoDTOApplication}
     * @memberof InfoHealthGettingResponseInfoDTO
     */
    'application'?: InfoHealthGettingResponseInfoDTOApplication;
    /**
     * 
     * @type {InfoHealthGettingResponseInfoDTOMemoryHeap}
     * @memberof InfoHealthGettingResponseInfoDTO
     */
    'memory_heap'?: InfoHealthGettingResponseInfoDTOMemoryHeap;
}
/**
 * Health application status
 * @export
 * @interface InfoHealthGettingResponseInfoDTOApplication
 */
export interface InfoHealthGettingResponseInfoDTOApplication {
    /**
     * Health item message
     * @type {string}
     * @memberof InfoHealthGettingResponseInfoDTOApplication
     */
    'message'?: string;
    /**
     * Health item status
     * @type {string}
     * @memberof InfoHealthGettingResponseInfoDTOApplication
     */
    'status'?: InfoHealthGettingResponseInfoDTOApplicationStatusEnum;
}

export const InfoHealthGettingResponseInfoDTOApplicationStatusEnum = {
    Down: 'down',
    Up: 'up'
} as const;

export type InfoHealthGettingResponseInfoDTOApplicationStatusEnum = typeof InfoHealthGettingResponseInfoDTOApplicationStatusEnum[keyof typeof InfoHealthGettingResponseInfoDTOApplicationStatusEnum];

/**
 * Health memory heap status
 * @export
 * @interface InfoHealthGettingResponseInfoDTOMemoryHeap
 */
export interface InfoHealthGettingResponseInfoDTOMemoryHeap {
    /**
     * Health item message
     * @type {string}
     * @memberof InfoHealthGettingResponseInfoDTOMemoryHeap
     */
    'message'?: string;
    /**
     * Health item status
     * @type {string}
     * @memberof InfoHealthGettingResponseInfoDTOMemoryHeap
     */
    'status'?: InfoHealthGettingResponseInfoDTOMemoryHeapStatusEnum;
}

export const InfoHealthGettingResponseInfoDTOMemoryHeapStatusEnum = {
    Down: 'down',
    Up: 'up'
} as const;

export type InfoHealthGettingResponseInfoDTOMemoryHeapStatusEnum = typeof InfoHealthGettingResponseInfoDTOMemoryHeapStatusEnum[keyof typeof InfoHealthGettingResponseInfoDTOMemoryHeapStatusEnum];

/**
 * 
 * @export
 * @interface InfoHealthGettingResponseInfoDataDTO
 */
export interface InfoHealthGettingResponseInfoDataDTO {
    /**
     * Health item message
     * @type {string}
     * @memberof InfoHealthGettingResponseInfoDataDTO
     */
    'message'?: string;
    /**
     * Health item status
     * @type {string}
     * @memberof InfoHealthGettingResponseInfoDataDTO
     */
    'status'?: InfoHealthGettingResponseInfoDataDTOStatusEnum;
}

export const InfoHealthGettingResponseInfoDataDTOStatusEnum = {
    Down: 'down',
    Up: 'up'
} as const;

export type InfoHealthGettingResponseInfoDataDTOStatusEnum = typeof InfoHealthGettingResponseInfoDataDTOStatusEnum[keyof typeof InfoHealthGettingResponseInfoDataDTOStatusEnum];

/**
 * 
 * @export
 * @interface InfoHealthGettingResponseInfoErrorDTO
 */
export interface InfoHealthGettingResponseInfoErrorDTO {
    /**
     * 
     * @type {InfoHealthGettingResponseInfoDTOApplication}
     * @memberof InfoHealthGettingResponseInfoErrorDTO
     */
    'application'?: InfoHealthGettingResponseInfoDTOApplication;
    /**
     * 
     * @type {InfoHealthGettingResponseInfoDTOMemoryHeap}
     * @memberof InfoHealthGettingResponseInfoErrorDTO
     */
    'memory_heap'?: InfoHealthGettingResponseInfoDTOMemoryHeap;
}
/**
 * 
 * @export
 * @interface InternalServerErrorResponseDTO
 */
export interface InternalServerErrorResponseDTO {
    /**
     * Correlation identifier
     * @type {string}
     * @memberof InternalServerErrorResponseDTO
     */
    'correlationID'?: string;
    /**
     * Error name
     * @type {string}
     * @memberof InternalServerErrorResponseDTO
     */
    'error'?: string;
    /**
     * Error message
     * @type {string}
     * @memberof InternalServerErrorResponseDTO
     */
    'message'?: string;
    /**
     * Error status code
     * @type {number}
     * @memberof InternalServerErrorResponseDTO
     */
    'statusCode'?: InternalServerErrorResponseDTOStatusCodeEnum;
    /**
     * Error timestamp
     * @type {number}
     * @memberof InternalServerErrorResponseDTO
     */
    'timestamp'?: number;
}

export const InternalServerErrorResponseDTOStatusCodeEnum = {
    NUMBER_100: 100,
    NUMBER_101: 101,
    NUMBER_102: 102,
    NUMBER_103: 103,
    NUMBER_200: 200,
    NUMBER_201: 201,
    NUMBER_202: 202,
    NUMBER_203: 203,
    NUMBER_204: 204,
    NUMBER_205: 205,
    NUMBER_206: 206,
    NUMBER_207: 207,
    NUMBER_208: 208,
    NUMBER_226: 226,
    NUMBER_300: 300,
    NUMBER_301: 301,
    NUMBER_302: 302,
    NUMBER_303: 303,
    NUMBER_304: 304,
    NUMBER_305: 305,
    NUMBER_306: 306,
    NUMBER_307: 307,
    NUMBER_308: 308,
    NUMBER_400: 400,
    NUMBER_401: 401,
    NUMBER_402: 402,
    NUMBER_403: 403,
    NUMBER_404: 404,
    NUMBER_405: 405,
    NUMBER_406: 406,
    NUMBER_407: 407,
    NUMBER_408: 408,
    NUMBER_409: 409,
    NUMBER_410: 410,
    NUMBER_411: 411,
    NUMBER_412: 412,
    NUMBER_413: 413,
    NUMBER_414: 414,
    NUMBER_415: 415,
    NUMBER_416: 416,
    NUMBER_417: 417,
    NUMBER_418: 418,
    NUMBER_421: 421,
    NUMBER_422: 422,
    NUMBER_423: 423,
    NUMBER_424: 424,
    NUMBER_425: 425,
    NUMBER_426: 426,
    NUMBER_428: 428,
    NUMBER_429: 429,
    NUMBER_431: 431,
    NUMBER_451: 451,
    NUMBER_500: 500,
    NUMBER_501: 501,
    NUMBER_502: 502,
    NUMBER_503: 503,
    NUMBER_504: 504,
    NUMBER_505: 505,
    NUMBER_506: 506,
    NUMBER_507: 507,
    NUMBER_508: 508,
    NUMBER_510: 510,
    NUMBER_511: 511
} as const;

export type InternalServerErrorResponseDTOStatusCodeEnum = typeof InternalServerErrorResponseDTOStatusCodeEnum[keyof typeof InternalServerErrorResponseDTOStatusCodeEnum];

/**
 * 
 * @export
 * @interface MessageCreateRequestBodyDTO
 */
export interface MessageCreateRequestBodyDTO {
    /**
     * Message hash
     * @type {string}
     * @memberof MessageCreateRequestBodyDTO
     */
    'hash': string;
    /**
     * Message 
     * @type {string}
     * @memberof MessageCreateRequestBodyDTO
     */
    'receivedAt': string;
    /**
     * Message text
     * @type {string}
     * @memberof MessageCreateRequestBodyDTO
     */
    'sender': string;
    /**
     * Message text
     * @type {string}
     * @memberof MessageCreateRequestBodyDTO
     */
    'text': string;
    /**
     * Currency type
     * @type {string}
     * @memberof MessageCreateRequestBodyDTO
     */
    'type': MessageCreateRequestBodyDTOTypeEnum;
}

export const MessageCreateRequestBodyDTOTypeEnum = {
    Push: 'push',
    Sms: 'sms'
} as const;

export type MessageCreateRequestBodyDTOTypeEnum = typeof MessageCreateRequestBodyDTOTypeEnum[keyof typeof MessageCreateRequestBodyDTOTypeEnum];

/**
 * 
 * @export
 * @interface NotFoundResponseDTO
 */
export interface NotFoundResponseDTO {
    /**
     * Correlation identifier
     * @type {string}
     * @memberof NotFoundResponseDTO
     */
    'correlationID'?: string;
    /**
     * Error name
     * @type {string}
     * @memberof NotFoundResponseDTO
     */
    'error'?: string;
    /**
     * Error message
     * @type {string}
     * @memberof NotFoundResponseDTO
     */
    'message'?: string;
    /**
     * Error status code
     * @type {number}
     * @memberof NotFoundResponseDTO
     */
    'statusCode'?: NotFoundResponseDTOStatusCodeEnum;
    /**
     * Error timestamp
     * @type {number}
     * @memberof NotFoundResponseDTO
     */
    'timestamp'?: number;
}

export const NotFoundResponseDTOStatusCodeEnum = {
    NUMBER_100: 100,
    NUMBER_101: 101,
    NUMBER_102: 102,
    NUMBER_103: 103,
    NUMBER_200: 200,
    NUMBER_201: 201,
    NUMBER_202: 202,
    NUMBER_203: 203,
    NUMBER_204: 204,
    NUMBER_205: 205,
    NUMBER_206: 206,
    NUMBER_207: 207,
    NUMBER_208: 208,
    NUMBER_226: 226,
    NUMBER_300: 300,
    NUMBER_301: 301,
    NUMBER_302: 302,
    NUMBER_303: 303,
    NUMBER_304: 304,
    NUMBER_305: 305,
    NUMBER_306: 306,
    NUMBER_307: 307,
    NUMBER_308: 308,
    NUMBER_400: 400,
    NUMBER_401: 401,
    NUMBER_402: 402,
    NUMBER_403: 403,
    NUMBER_404: 404,
    NUMBER_405: 405,
    NUMBER_406: 406,
    NUMBER_407: 407,
    NUMBER_408: 408,
    NUMBER_409: 409,
    NUMBER_410: 410,
    NUMBER_411: 411,
    NUMBER_412: 412,
    NUMBER_413: 413,
    NUMBER_414: 414,
    NUMBER_415: 415,
    NUMBER_416: 416,
    NUMBER_417: 417,
    NUMBER_418: 418,
    NUMBER_421: 421,
    NUMBER_422: 422,
    NUMBER_423: 423,
    NUMBER_424: 424,
    NUMBER_425: 425,
    NUMBER_426: 426,
    NUMBER_428: 428,
    NUMBER_429: 429,
    NUMBER_431: 431,
    NUMBER_451: 451,
    NUMBER_500: 500,
    NUMBER_501: 501,
    NUMBER_502: 502,
    NUMBER_503: 503,
    NUMBER_504: 504,
    NUMBER_505: 505,
    NUMBER_506: 506,
    NUMBER_507: 507,
    NUMBER_508: 508,
    NUMBER_510: 510,
    NUMBER_511: 511
} as const;

export type NotFoundResponseDTOStatusCodeEnum = typeof NotFoundResponseDTOStatusCodeEnum[keyof typeof NotFoundResponseDTOStatusCodeEnum];

/**
 * 
 * @export
 * @interface StatisticsGetResponseDTO
 */
export interface StatisticsGetResponseDTO {
    /**
     * Statistics sum amount
     * @type {number}
     * @memberof StatisticsGetResponseDTO
     */
    'amount'?: number;
    /**
     * Statistics total conversion
     * @type {number}
     * @memberof StatisticsGetResponseDTO
     */
    'conversion'?: number;
    /**
     * Statistics date
     * @type {string}
     * @memberof StatisticsGetResponseDTO
     */
    'date'?: string;
    /**
     * Statistics successful count
     * @type {number}
     * @memberof StatisticsGetResponseDTO
     */
    'successfullCount'?: number;
    /**
     * Statistics total count
     * @type {number}
     * @memberof StatisticsGetResponseDTO
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface StatisticsGetSimpleListResponseDTO
 */
export interface StatisticsGetSimpleListResponseDTO {
    /**
     * Array of StatisticsGetResponseDTO 
     * @type {Set<StatisticsGetResponseDTO>}
     * @memberof StatisticsGetSimpleListResponseDTO
     */
    'items'?: Set<StatisticsGetResponseDTO>;
    /**
     * StatisticsGetResponseDTO Total number of items
     * @type {number}
     * @memberof StatisticsGetSimpleListResponseDTO
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface TooManyRequestsResponseDTO
 */
export interface TooManyRequestsResponseDTO {
    /**
     * Correlation identifier
     * @type {string}
     * @memberof TooManyRequestsResponseDTO
     */
    'correlationID'?: string;
    /**
     * Error name
     * @type {string}
     * @memberof TooManyRequestsResponseDTO
     */
    'error'?: string;
    /**
     * Error message
     * @type {string}
     * @memberof TooManyRequestsResponseDTO
     */
    'message'?: string;
    /**
     * Error status code
     * @type {number}
     * @memberof TooManyRequestsResponseDTO
     */
    'statusCode'?: TooManyRequestsResponseDTOStatusCodeEnum;
    /**
     * Error timestamp
     * @type {number}
     * @memberof TooManyRequestsResponseDTO
     */
    'timestamp'?: number;
}

export const TooManyRequestsResponseDTOStatusCodeEnum = {
    NUMBER_100: 100,
    NUMBER_101: 101,
    NUMBER_102: 102,
    NUMBER_103: 103,
    NUMBER_200: 200,
    NUMBER_201: 201,
    NUMBER_202: 202,
    NUMBER_203: 203,
    NUMBER_204: 204,
    NUMBER_205: 205,
    NUMBER_206: 206,
    NUMBER_207: 207,
    NUMBER_208: 208,
    NUMBER_226: 226,
    NUMBER_300: 300,
    NUMBER_301: 301,
    NUMBER_302: 302,
    NUMBER_303: 303,
    NUMBER_304: 304,
    NUMBER_305: 305,
    NUMBER_306: 306,
    NUMBER_307: 307,
    NUMBER_308: 308,
    NUMBER_400: 400,
    NUMBER_401: 401,
    NUMBER_402: 402,
    NUMBER_403: 403,
    NUMBER_404: 404,
    NUMBER_405: 405,
    NUMBER_406: 406,
    NUMBER_407: 407,
    NUMBER_408: 408,
    NUMBER_409: 409,
    NUMBER_410: 410,
    NUMBER_411: 411,
    NUMBER_412: 412,
    NUMBER_413: 413,
    NUMBER_414: 414,
    NUMBER_415: 415,
    NUMBER_416: 416,
    NUMBER_417: 417,
    NUMBER_418: 418,
    NUMBER_421: 421,
    NUMBER_422: 422,
    NUMBER_423: 423,
    NUMBER_424: 424,
    NUMBER_425: 425,
    NUMBER_426: 426,
    NUMBER_428: 428,
    NUMBER_429: 429,
    NUMBER_431: 431,
    NUMBER_451: 451,
    NUMBER_500: 500,
    NUMBER_501: 501,
    NUMBER_502: 502,
    NUMBER_503: 503,
    NUMBER_504: 504,
    NUMBER_505: 505,
    NUMBER_506: 506,
    NUMBER_507: 507,
    NUMBER_508: 508,
    NUMBER_510: 510,
    NUMBER_511: 511
} as const;

export type TooManyRequestsResponseDTOStatusCodeEnum = typeof TooManyRequestsResponseDTOStatusCodeEnum[keyof typeof TooManyRequestsResponseDTOStatusCodeEnum];

/**
 * 
 * @export
 * @interface TypeCreateRequestBodyDTO
 */
export interface TypeCreateRequestBodyDTO {
    /**
     * Type mask
     * @type {string}
     * @memberof TypeCreateRequestBodyDTO
     */
    'mask': string;
    /**
     * Type name
     * @type {string}
     * @memberof TypeCreateRequestBodyDTO
     */
    'name': string;
    /**
     * Type pursePattern
     * @type {string}
     * @memberof TypeCreateRequestBodyDTO
     */
    'pursePattern': string;
    /**
     * Type type
     * @type {string}
     * @memberof TypeCreateRequestBodyDTO
     */
    'purseType': TypeCreateRequestBodyDTOPurseTypeEnum;
}

export const TypeCreateRequestBodyDTOPurseTypeEnum = {
    Card: 'card',
    Wallet: 'wallet'
} as const;

export type TypeCreateRequestBodyDTOPurseTypeEnum = typeof TypeCreateRequestBodyDTOPurseTypeEnum[keyof typeof TypeCreateRequestBodyDTOPurseTypeEnum];

/**
 * 
 * @export
 * @interface TypeCreateResponseDTO
 */
export interface TypeCreateResponseDTO {
    /**
     * Type creation date
     * @type {string}
     * @memberof TypeCreateResponseDTO
     */
    'createdAt'?: string;
    /**
     * Type identifier
     * @type {string}
     * @memberof TypeCreateResponseDTO
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface TypeGetListResponseDTO
 */
export interface TypeGetListResponseDTO {
    /**
     * TypeGetResponseDTO Total number of items on page
     * @type {number}
     * @memberof TypeGetListResponseDTO
     */
    'count'?: number;
    /**
     * TypeGetResponseDTO Current page number
     * @type {number}
     * @memberof TypeGetListResponseDTO
     */
    'currentPage'?: number;
    /**
     * Array of TypeGetResponseDTO 
     * @type {Set<TypeGetResponseDTO>}
     * @memberof TypeGetListResponseDTO
     */
    'items'?: Set<TypeGetResponseDTO>;
    /**
     * TypeGetResponseDTO Total number of items
     * @type {number}
     * @memberof TypeGetListResponseDTO
     */
    'totalCount'?: number;
    /**
     * TypeGetResponseDTO Total number of pages
     * @type {number}
     * @memberof TypeGetListResponseDTO
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface TypeGetResponseDTO
 */
export interface TypeGetResponseDTO {
    /**
     * Type creation date
     * @type {string}
     * @memberof TypeGetResponseDTO
     */
    'createdAt'?: string;
    /**
     * Type identifier
     * @type {string}
     * @memberof TypeGetResponseDTO
     */
    'id'?: string;
    /**
     * Type mask
     * @type {string}
     * @memberof TypeGetResponseDTO
     */
    'mask'?: string;
    /**
     * Type name
     * @type {string}
     * @memberof TypeGetResponseDTO
     */
    'name'?: string;
    /**
     * Type pursePattern
     * @type {string}
     * @memberof TypeGetResponseDTO
     */
    'pursePattern'?: string;
    /**
     * Type type
     * @type {string}
     * @memberof TypeGetResponseDTO
     */
    'purseType'?: TypeGetResponseDTOPurseTypeEnum;
    /**
     * Type last update date
     * @type {string}
     * @memberof TypeGetResponseDTO
     */
    'updatedAt'?: string;
}

export const TypeGetResponseDTOPurseTypeEnum = {
    Card: 'card',
    Wallet: 'wallet'
} as const;

export type TypeGetResponseDTOPurseTypeEnum = typeof TypeGetResponseDTOPurseTypeEnum[keyof typeof TypeGetResponseDTOPurseTypeEnum];

/**
 * 
 * @export
 * @interface TypePartialUpdateRequestBodyDTO
 */
export interface TypePartialUpdateRequestBodyDTO {
    /**
     * Type mask
     * @type {string}
     * @memberof TypePartialUpdateRequestBodyDTO
     */
    'mask'?: string;
    /**
     * Type name
     * @type {string}
     * @memberof TypePartialUpdateRequestBodyDTO
     */
    'name'?: string;
    /**
     * Type pursePattern
     * @type {string}
     * @memberof TypePartialUpdateRequestBodyDTO
     */
    'pursePattern'?: string;
    /**
     * Type type
     * @type {string}
     * @memberof TypePartialUpdateRequestBodyDTO
     */
    'purseType'?: TypePartialUpdateRequestBodyDTOPurseTypeEnum;
}

export const TypePartialUpdateRequestBodyDTOPurseTypeEnum = {
    Card: 'card',
    Wallet: 'wallet'
} as const;

export type TypePartialUpdateRequestBodyDTOPurseTypeEnum = typeof TypePartialUpdateRequestBodyDTOPurseTypeEnum[keyof typeof TypePartialUpdateRequestBodyDTOPurseTypeEnum];

/**
 * 
 * @export
 * @interface TypePartialUpdateResponseDTO
 */
export interface TypePartialUpdateResponseDTO {
    /**
     * Type creation date
     * @type {string}
     * @memberof TypePartialUpdateResponseDTO
     */
    'createdAt'?: string;
    /**
     * Type identifier
     * @type {string}
     * @memberof TypePartialUpdateResponseDTO
     */
    'id'?: string;
    /**
     * Type name
     * @type {string}
     * @memberof TypePartialUpdateResponseDTO
     */
    'name'?: string;
    /**
     * Type pursePattern
     * @type {string}
     * @memberof TypePartialUpdateResponseDTO
     */
    'pursePattern'?: string;
    /**
     * Type type
     * @type {string}
     * @memberof TypePartialUpdateResponseDTO
     */
    'purseType'?: TypePartialUpdateResponseDTOPurseTypeEnum;
    /**
     * Type last update date
     * @type {string}
     * @memberof TypePartialUpdateResponseDTO
     */
    'updatedAt'?: string;
}

export const TypePartialUpdateResponseDTOPurseTypeEnum = {
    Card: 'card',
    Wallet: 'wallet'
} as const;

export type TypePartialUpdateResponseDTOPurseTypeEnum = typeof TypePartialUpdateResponseDTOPurseTypeEnum[keyof typeof TypePartialUpdateResponseDTOPurseTypeEnum];

/**
 * 
 * @export
 * @interface TypeUpdateRequestBodyDTO
 */
export interface TypeUpdateRequestBodyDTO {
    /**
     * Type mask
     * @type {string}
     * @memberof TypeUpdateRequestBodyDTO
     */
    'mask': string;
    /**
     * Type name
     * @type {string}
     * @memberof TypeUpdateRequestBodyDTO
     */
    'name': string;
    /**
     * Type pursePattern
     * @type {string}
     * @memberof TypeUpdateRequestBodyDTO
     */
    'pursePattern': string;
    /**
     * Type type
     * @type {string}
     * @memberof TypeUpdateRequestBodyDTO
     */
    'purseType': TypeUpdateRequestBodyDTOPurseTypeEnum;
}

export const TypeUpdateRequestBodyDTOPurseTypeEnum = {
    Card: 'card',
    Wallet: 'wallet'
} as const;

export type TypeUpdateRequestBodyDTOPurseTypeEnum = typeof TypeUpdateRequestBodyDTOPurseTypeEnum[keyof typeof TypeUpdateRequestBodyDTOPurseTypeEnum];

/**
 * 
 * @export
 * @interface TypeUpdateResponseDTO
 */
export interface TypeUpdateResponseDTO {
    /**
     * Type creation date
     * @type {string}
     * @memberof TypeUpdateResponseDTO
     */
    'createdAt'?: string;
    /**
     * Type identifier
     * @type {string}
     * @memberof TypeUpdateResponseDTO
     */
    'id'?: string;
    /**
     * Type name
     * @type {string}
     * @memberof TypeUpdateResponseDTO
     */
    'name'?: string;
    /**
     * Type pursePattern
     * @type {string}
     * @memberof TypeUpdateResponseDTO
     */
    'pursePattern'?: string;
    /**
     * Type type
     * @type {string}
     * @memberof TypeUpdateResponseDTO
     */
    'purseType'?: TypeUpdateResponseDTOPurseTypeEnum;
    /**
     * Type last update date
     * @type {string}
     * @memberof TypeUpdateResponseDTO
     */
    'updatedAt'?: string;
}

export const TypeUpdateResponseDTOPurseTypeEnum = {
    Card: 'card',
    Wallet: 'wallet'
} as const;

export type TypeUpdateResponseDTOPurseTypeEnum = typeof TypeUpdateResponseDTOPurseTypeEnum[keyof typeof TypeUpdateResponseDTOPurseTypeEnum];

/**
 * 
 * @export
 * @interface UnauthorizedResponseDTO
 */
export interface UnauthorizedResponseDTO {
    /**
     * Correlation identifier
     * @type {string}
     * @memberof UnauthorizedResponseDTO
     */
    'correlationID'?: string;
    /**
     * Error name
     * @type {string}
     * @memberof UnauthorizedResponseDTO
     */
    'error'?: string;
    /**
     * Error message
     * @type {string}
     * @memberof UnauthorizedResponseDTO
     */
    'message'?: string;
    /**
     * Error status code
     * @type {number}
     * @memberof UnauthorizedResponseDTO
     */
    'statusCode'?: UnauthorizedResponseDTOStatusCodeEnum;
    /**
     * Error timestamp
     * @type {number}
     * @memberof UnauthorizedResponseDTO
     */
    'timestamp'?: number;
}

export const UnauthorizedResponseDTOStatusCodeEnum = {
    NUMBER_100: 100,
    NUMBER_101: 101,
    NUMBER_102: 102,
    NUMBER_103: 103,
    NUMBER_200: 200,
    NUMBER_201: 201,
    NUMBER_202: 202,
    NUMBER_203: 203,
    NUMBER_204: 204,
    NUMBER_205: 205,
    NUMBER_206: 206,
    NUMBER_207: 207,
    NUMBER_208: 208,
    NUMBER_226: 226,
    NUMBER_300: 300,
    NUMBER_301: 301,
    NUMBER_302: 302,
    NUMBER_303: 303,
    NUMBER_304: 304,
    NUMBER_305: 305,
    NUMBER_306: 306,
    NUMBER_307: 307,
    NUMBER_308: 308,
    NUMBER_400: 400,
    NUMBER_401: 401,
    NUMBER_402: 402,
    NUMBER_403: 403,
    NUMBER_404: 404,
    NUMBER_405: 405,
    NUMBER_406: 406,
    NUMBER_407: 407,
    NUMBER_408: 408,
    NUMBER_409: 409,
    NUMBER_410: 410,
    NUMBER_411: 411,
    NUMBER_412: 412,
    NUMBER_413: 413,
    NUMBER_414: 414,
    NUMBER_415: 415,
    NUMBER_416: 416,
    NUMBER_417: 417,
    NUMBER_418: 418,
    NUMBER_421: 421,
    NUMBER_422: 422,
    NUMBER_423: 423,
    NUMBER_424: 424,
    NUMBER_425: 425,
    NUMBER_426: 426,
    NUMBER_428: 428,
    NUMBER_429: 429,
    NUMBER_431: 431,
    NUMBER_451: 451,
    NUMBER_500: 500,
    NUMBER_501: 501,
    NUMBER_502: 502,
    NUMBER_503: 503,
    NUMBER_504: 504,
    NUMBER_505: 505,
    NUMBER_506: 506,
    NUMBER_507: 507,
    NUMBER_508: 508,
    NUMBER_510: 510,
    NUMBER_511: 511
} as const;

export type UnauthorizedResponseDTOStatusCodeEnum = typeof UnauthorizedResponseDTOStatusCodeEnum[keyof typeof UnauthorizedResponseDTOStatusCodeEnum];

/**
 * 
 * @export
 * @interface UserBalanceGetListResponseDTO
 */
export interface UserBalanceGetListResponseDTO {
    /**
     * UserBalanceGetResponseDTO Total number of items on page
     * @type {number}
     * @memberof UserBalanceGetListResponseDTO
     */
    'count'?: number;
    /**
     * UserBalanceGetResponseDTO Current page number
     * @type {number}
     * @memberof UserBalanceGetListResponseDTO
     */
    'currentPage'?: number;
    /**
     * Array of UserBalanceGetResponseDTO 
     * @type {Set<UserBalanceGetResponseDTO>}
     * @memberof UserBalanceGetListResponseDTO
     */
    'items'?: Set<UserBalanceGetResponseDTO>;
    /**
     * UserBalanceGetResponseDTO Total number of items
     * @type {number}
     * @memberof UserBalanceGetListResponseDTO
     */
    'totalCount'?: number;
    /**
     * UserBalanceGetResponseDTO Total number of pages
     * @type {number}
     * @memberof UserBalanceGetListResponseDTO
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface UserBalanceGetResponseCurrencyDTO
 */
export interface UserBalanceGetResponseCurrencyDTO {
    /**
     * UserBalance currency identifier
     * @type {string}
     * @memberof UserBalanceGetResponseCurrencyDTO
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface UserBalanceGetResponseDTO
 */
export interface UserBalanceGetResponseDTO {
    /**
     * UserBalance amount in hundredths of a coin (e.g. cents for dollars, kopecks for rubles, etc.)
     * @type {number}
     * @memberof UserBalanceGetResponseDTO
     */
    'balance'?: number;
    /**
     * UserBalance creation date
     * @type {string}
     * @memberof UserBalanceGetResponseDTO
     */
    'createdAt'?: string;
    /**
     * 
     * @type {UserBalanceGetResponseDTOCurrency}
     * @memberof UserBalanceGetResponseDTO
     */
    'currency'?: UserBalanceGetResponseDTOCurrency;
    /**
     * UserBalance identifier
     * @type {string}
     * @memberof UserBalanceGetResponseDTO
     */
    'id'?: string;
    /**
     * UserBalance last update date
     * @type {string}
     * @memberof UserBalanceGetResponseDTO
     */
    'updatedAt'?: string;
}
/**
 * UserBalance currency
 * @export
 * @interface UserBalanceGetResponseDTOCurrency
 */
export interface UserBalanceGetResponseDTOCurrency {
    /**
     * UserBalance currency identifier
     * @type {string}
     * @memberof UserBalanceGetResponseDTOCurrency
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface UserBalanceLogGetListResponseDTO
 */
export interface UserBalanceLogGetListResponseDTO {
    /**
     * UserBalanceLogGetResponseDTO Total number of items on page
     * @type {number}
     * @memberof UserBalanceLogGetListResponseDTO
     */
    'count'?: number;
    /**
     * UserBalanceLogGetResponseDTO Current page number
     * @type {number}
     * @memberof UserBalanceLogGetListResponseDTO
     */
    'currentPage'?: number;
    /**
     * Array of UserBalanceLogGetResponseDTO 
     * @type {Set<UserBalanceLogGetResponseDTO>}
     * @memberof UserBalanceLogGetListResponseDTO
     */
    'items'?: Set<UserBalanceLogGetResponseDTO>;
    /**
     * UserBalanceLogGetResponseDTO Total number of items
     * @type {number}
     * @memberof UserBalanceLogGetListResponseDTO
     */
    'totalCount'?: number;
    /**
     * UserBalanceLogGetResponseDTO Total number of pages
     * @type {number}
     * @memberof UserBalanceLogGetListResponseDTO
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface UserBalanceLogGetResponseDTO
 */
export interface UserBalanceLogGetResponseDTO {
    /**
     * UserBalanceLog Amount in hundredths of a coin (e.g. cents for dollars, kopecks for rubles, etc.)
     * @type {number}
     * @memberof UserBalanceLogGetResponseDTO
     */
    'amount'?: number;
    /**
     * UserBalanceLog creation date
     * @type {string}
     * @memberof UserBalanceLogGetResponseDTO
     */
    'createdAt'?: string;
    /**
     * 
     * @type {UserBalanceLogGetResponseDTODeposit}
     * @memberof UserBalanceLogGetResponseDTO
     */
    'deposit'?: UserBalanceLogGetResponseDTODeposit | null;
    /**
     * UserBalanceLog Balance before transaction
     * @type {number}
     * @memberof UserBalanceLogGetResponseDTO
     */
    'fromValue'?: number;
    /**
     * UserBalanceLog identifier
     * @type {string}
     * @memberof UserBalanceLogGetResponseDTO
     */
    'id'?: string;
    /**
     * UserBalanceLog Balance after transaction
     * @type {number}
     * @memberof UserBalanceLogGetResponseDTO
     */
    'toValue'?: number;
    /**
     * 
     * @type {UserBalanceLogGetResponseDTOTransfer}
     * @memberof UserBalanceLogGetResponseDTO
     */
    'transfer'?: UserBalanceLogGetResponseDTOTransfer | null;
    /**
     * UserBalanceLog type
     * @type {string}
     * @memberof UserBalanceLogGetResponseDTO
     */
    'type'?: UserBalanceLogGetResponseDTOTypeEnum;
}

export const UserBalanceLogGetResponseDTOTypeEnum = {
    Deposit: 'deposit',
    Transfer: 'transfer'
} as const;

export type UserBalanceLogGetResponseDTOTypeEnum = typeof UserBalanceLogGetResponseDTOTypeEnum[keyof typeof UserBalanceLogGetResponseDTOTypeEnum];

/**
 * UserBalanceLog associated deposit
 * @export
 * @interface UserBalanceLogGetResponseDTODeposit
 */
export interface UserBalanceLogGetResponseDTODeposit {
    /**
     * UserBalanceLog deposit identifier
     * @type {string}
     * @memberof UserBalanceLogGetResponseDTODeposit
     */
    'id'?: string;
}
/**
 * UserBalanceLog associated transfer
 * @export
 * @interface UserBalanceLogGetResponseDTOTransfer
 */
export interface UserBalanceLogGetResponseDTOTransfer {
    /**
     * UserBalanceLog transfer identifier
     * @type {string}
     * @memberof UserBalanceLogGetResponseDTOTransfer
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface UserBalanceLogGetResponseDepositDTO
 */
export interface UserBalanceLogGetResponseDepositDTO {
    /**
     * UserBalanceLog deposit identifier
     * @type {string}
     * @memberof UserBalanceLogGetResponseDepositDTO
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface UserBalanceLogGetResponseTransferDTO
 */
export interface UserBalanceLogGetResponseTransferDTO {
    /**
     * UserBalanceLog transfer identifier
     * @type {string}
     * @memberof UserBalanceLogGetResponseTransferDTO
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface UserGetResponseDTO
 */
export interface UserGetResponseDTO {
    /**
     * User creation date
     * @type {string}
     * @memberof UserGetResponseDTO
     */
    'createdAt'?: string;
    /**
     * User identifier
     * @type {string}
     * @memberof UserGetResponseDTO
     */
    'id'?: string;
    /**
     * User login
     * @type {string}
     * @memberof UserGetResponseDTO
     */
    'login'?: string;
    /**
     * User last update date
     * @type {string}
     * @memberof UserGetResponseDTO
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface UserPartialUpdateRequestBodyDTO
 */
export interface UserPartialUpdateRequestBodyDTO {
    /**
     * User login
     * @type {string}
     * @memberof UserPartialUpdateRequestBodyDTO
     */
    'login'?: string;
}
/**
 * 
 * @export
 * @interface UserPartialUpdateResponseDTO
 */
export interface UserPartialUpdateResponseDTO {
    /**
     * User creation date
     * @type {string}
     * @memberof UserPartialUpdateResponseDTO
     */
    'createdAt'?: string;
    /**
     * User identifier
     * @type {string}
     * @memberof UserPartialUpdateResponseDTO
     */
    'id'?: string;
    /**
     * User login
     * @type {string}
     * @memberof UserPartialUpdateResponseDTO
     */
    'login'?: string;
    /**
     * User last update date
     * @type {string}
     * @memberof UserPartialUpdateResponseDTO
     */
    'updatedAt'?: string;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This method is used for creating `Account`
         * @summary Creating `Account`
         * @param {AccountCreateRequestBodyDTO} accountCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerCreate: async (accountCreateRequestBodyDTO: AccountCreateRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountCreateRequestBodyDTO' is not null or undefined
            assertParamExists('accountControllerCreate', 'accountCreateRequestBodyDTO', accountCreateRequestBodyDTO)
            const localVarPath = `/v1/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountCreateRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for deleting `Account`
         * @summary Deleting `Account`
         * @param {string} account Account identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerDelete: async (account: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'account' is not null or undefined
            assertParamExists('accountControllerDelete', 'account', account)
            const localVarPath = `/v1/account/{account}`
                .replace(`{${"account"}}`, encodeURIComponent(String(account)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for fetching `Account`
         * @summary Fetching `Account`
         * @param {string} account Account identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerGet: async (account: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'account' is not null or undefined
            assertParamExists('accountControllerGet', 'account', account)
            const localVarPath = `/v1/account/{account}`
                .replace(`{${"account"}}`, encodeURIComponent(String(account)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for fetching list of `Accounts`
         * @summary Fetching list of `Accounts`
         * @param {number} limit AccountGetResponseDTO Items per page
         * @param {number} page AccountGetResponseDTO Page to return
         * @param {'createdAt' | 'updatedAt'} orderBy Account order field
         * @param {'asc' | 'desc'} orderDirection Account order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerGetList: async (limit: number, page: number, orderBy: 'createdAt' | 'updatedAt', orderDirection: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('accountControllerGetList', 'limit', limit)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('accountControllerGetList', 'page', page)
            // verify required parameter 'orderBy' is not null or undefined
            assertParamExists('accountControllerGetList', 'orderBy', orderBy)
            // verify required parameter 'orderDirection' is not null or undefined
            assertParamExists('accountControllerGetList', 'orderDirection', orderDirection)
            const localVarPath = `/v1/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for updating `Account`
         * @summary Updating `Account`
         * @param {string} account Account identifier
         * @param {AccountPartialUpdateRequestBodyDTO} accountPartialUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerPartialUpdate: async (account: string, accountPartialUpdateRequestBodyDTO: AccountPartialUpdateRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'account' is not null or undefined
            assertParamExists('accountControllerPartialUpdate', 'account', account)
            // verify required parameter 'accountPartialUpdateRequestBodyDTO' is not null or undefined
            assertParamExists('accountControllerPartialUpdate', 'accountPartialUpdateRequestBodyDTO', accountPartialUpdateRequestBodyDTO)
            const localVarPath = `/v1/account/{account}`
                .replace(`{${"account"}}`, encodeURIComponent(String(account)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountPartialUpdateRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for updating `Account`
         * @summary Updating `Account`
         * @param {string} account Account identifier
         * @param {AccountUpdateRequestBodyDTO} accountUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdate: async (account: string, accountUpdateRequestBodyDTO: AccountUpdateRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'account' is not null or undefined
            assertParamExists('accountControllerUpdate', 'account', account)
            // verify required parameter 'accountUpdateRequestBodyDTO' is not null or undefined
            assertParamExists('accountControllerUpdate', 'accountUpdateRequestBodyDTO', accountUpdateRequestBodyDTO)
            const localVarPath = `/v1/account/{account}`
                .replace(`{${"account"}}`, encodeURIComponent(String(account)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountUpdateRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * This method is used for creating `Account`
         * @summary Creating `Account`
         * @param {AccountCreateRequestBodyDTO} accountCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerCreate(accountCreateRequestBodyDTO: AccountCreateRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountCreateResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerCreate(accountCreateRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for deleting `Account`
         * @summary Deleting `Account`
         * @param {string} account Account identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerDelete(account: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerDelete(account, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for fetching `Account`
         * @summary Fetching `Account`
         * @param {string} account Account identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerGet(account: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountGetResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerGet(account, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for fetching list of `Accounts`
         * @summary Fetching list of `Accounts`
         * @param {number} limit AccountGetResponseDTO Items per page
         * @param {number} page AccountGetResponseDTO Page to return
         * @param {'createdAt' | 'updatedAt'} orderBy Account order field
         * @param {'asc' | 'desc'} orderDirection Account order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerGetList(limit: number, page: number, orderBy: 'createdAt' | 'updatedAt', orderDirection: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountGetListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerGetList(limit, page, orderBy, orderDirection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for updating `Account`
         * @summary Updating `Account`
         * @param {string} account Account identifier
         * @param {AccountPartialUpdateRequestBodyDTO} accountPartialUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerPartialUpdate(account: string, accountPartialUpdateRequestBodyDTO: AccountPartialUpdateRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountPartialUpdateResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerPartialUpdate(account, accountPartialUpdateRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for updating `Account`
         * @summary Updating `Account`
         * @param {string} account Account identifier
         * @param {AccountUpdateRequestBodyDTO} accountUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerUpdate(account: string, accountUpdateRequestBodyDTO: AccountUpdateRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountUpdateResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerUpdate(account, accountUpdateRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * This method is used for creating `Account`
         * @summary Creating `Account`
         * @param {AccountCreateRequestBodyDTO} accountCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerCreate(accountCreateRequestBodyDTO: AccountCreateRequestBodyDTO, options?: any): AxiosPromise<AccountCreateResponseDTO> {
            return localVarFp.accountControllerCreate(accountCreateRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for deleting `Account`
         * @summary Deleting `Account`
         * @param {string} account Account identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerDelete(account: string, options?: any): AxiosPromise<void> {
            return localVarFp.accountControllerDelete(account, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for fetching `Account`
         * @summary Fetching `Account`
         * @param {string} account Account identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerGet(account: string, options?: any): AxiosPromise<AccountGetResponseDTO> {
            return localVarFp.accountControllerGet(account, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for fetching list of `Accounts`
         * @summary Fetching list of `Accounts`
         * @param {number} limit AccountGetResponseDTO Items per page
         * @param {number} page AccountGetResponseDTO Page to return
         * @param {'createdAt' | 'updatedAt'} orderBy Account order field
         * @param {'asc' | 'desc'} orderDirection Account order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerGetList(limit: number, page: number, orderBy: 'createdAt' | 'updatedAt', orderDirection: 'asc' | 'desc', options?: any): AxiosPromise<AccountGetListResponseDTO> {
            return localVarFp.accountControllerGetList(limit, page, orderBy, orderDirection, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for updating `Account`
         * @summary Updating `Account`
         * @param {string} account Account identifier
         * @param {AccountPartialUpdateRequestBodyDTO} accountPartialUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerPartialUpdate(account: string, accountPartialUpdateRequestBodyDTO: AccountPartialUpdateRequestBodyDTO, options?: any): AxiosPromise<AccountPartialUpdateResponseDTO> {
            return localVarFp.accountControllerPartialUpdate(account, accountPartialUpdateRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for updating `Account`
         * @summary Updating `Account`
         * @param {string} account Account identifier
         * @param {AccountUpdateRequestBodyDTO} accountUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdate(account: string, accountUpdateRequestBodyDTO: AccountUpdateRequestBodyDTO, options?: any): AxiosPromise<AccountUpdateResponseDTO> {
            return localVarFp.accountControllerUpdate(account, accountUpdateRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * This method is used for creating `Account`
     * @summary Creating `Account`
     * @param {AccountCreateRequestBodyDTO} accountCreateRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerCreate(accountCreateRequestBodyDTO: AccountCreateRequestBodyDTO, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountControllerCreate(accountCreateRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for deleting `Account`
     * @summary Deleting `Account`
     * @param {string} account Account identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerDelete(account: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountControllerDelete(account, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for fetching `Account`
     * @summary Fetching `Account`
     * @param {string} account Account identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerGet(account: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountControllerGet(account, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for fetching list of `Accounts`
     * @summary Fetching list of `Accounts`
     * @param {number} limit AccountGetResponseDTO Items per page
     * @param {number} page AccountGetResponseDTO Page to return
     * @param {'createdAt' | 'updatedAt'} orderBy Account order field
     * @param {'asc' | 'desc'} orderDirection Account order direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerGetList(limit: number, page: number, orderBy: 'createdAt' | 'updatedAt', orderDirection: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountControllerGetList(limit, page, orderBy, orderDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for updating `Account`
     * @summary Updating `Account`
     * @param {string} account Account identifier
     * @param {AccountPartialUpdateRequestBodyDTO} accountPartialUpdateRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerPartialUpdate(account: string, accountPartialUpdateRequestBodyDTO: AccountPartialUpdateRequestBodyDTO, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountControllerPartialUpdate(account, accountPartialUpdateRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for updating `Account`
     * @summary Updating `Account`
     * @param {string} account Account identifier
     * @param {AccountUpdateRequestBodyDTO} accountUpdateRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerUpdate(account: string, accountUpdateRequestBodyDTO: AccountUpdateRequestBodyDTO, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountControllerUpdate(account, accountUpdateRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountStatisticsApi - axios parameter creator
 * @export
 */
export const AccountStatisticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This method is used for fetching simple list of `Statisticss`
         * @summary Fetching simple list of `Statisticss`
         * @param {'day' | 'hour' | 'month' | 'week' | 'year'} groupBy Statistics group by
         * @param {'amount' | 'conversion' | 'date' | 'successfullCount' | 'totalCount'} orderBy Statistics order field
         * @param {'asc' | 'desc'} orderDirection Statistics order direction
         * @param {'deposit' | 'transfer'} type Statistics type
         * @param {string} [dateFrom] Statistics from date
         * @param {string} [dateTo] Statistics to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountStatisticsControllerGet: async (groupBy: 'day' | 'hour' | 'month' | 'week' | 'year', orderBy: 'amount' | 'conversion' | 'date' | 'successfullCount' | 'totalCount', orderDirection: 'asc' | 'desc', type: 'deposit' | 'transfer', dateFrom?: string, dateTo?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupBy' is not null or undefined
            assertParamExists('accountStatisticsControllerGet', 'groupBy', groupBy)
            // verify required parameter 'orderBy' is not null or undefined
            assertParamExists('accountStatisticsControllerGet', 'orderBy', orderBy)
            // verify required parameter 'orderDirection' is not null or undefined
            assertParamExists('accountStatisticsControllerGet', 'orderDirection', orderDirection)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('accountStatisticsControllerGet', 'type', type)
            const localVarPath = `/v1/account/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accountAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication accountRequestSignature required
            await setApiKeyToObject(localVarHeaderParameter, "X-Signature", configuration)

            // authentication accountRequestTimestamp required
            await setApiKeyToObject(localVarHeaderParameter, "X-Timestamp", configuration)

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString() :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString() :
                    dateTo;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountStatisticsApi - functional programming interface
 * @export
 */
export const AccountStatisticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountStatisticsApiAxiosParamCreator(configuration)
    return {
        /**
         * This method is used for fetching simple list of `Statisticss`
         * @summary Fetching simple list of `Statisticss`
         * @param {'day' | 'hour' | 'month' | 'week' | 'year'} groupBy Statistics group by
         * @param {'amount' | 'conversion' | 'date' | 'successfullCount' | 'totalCount'} orderBy Statistics order field
         * @param {'asc' | 'desc'} orderDirection Statistics order direction
         * @param {'deposit' | 'transfer'} type Statistics type
         * @param {string} [dateFrom] Statistics from date
         * @param {string} [dateTo] Statistics to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountStatisticsControllerGet(groupBy: 'day' | 'hour' | 'month' | 'week' | 'year', orderBy: 'amount' | 'conversion' | 'date' | 'successfullCount' | 'totalCount', orderDirection: 'asc' | 'desc', type: 'deposit' | 'transfer', dateFrom?: string, dateTo?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountStatisticsGetSimpleListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountStatisticsControllerGet(groupBy, orderBy, orderDirection, type, dateFrom, dateTo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountStatisticsApi - factory interface
 * @export
 */
export const AccountStatisticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountStatisticsApiFp(configuration)
    return {
        /**
         * This method is used for fetching simple list of `Statisticss`
         * @summary Fetching simple list of `Statisticss`
         * @param {'day' | 'hour' | 'month' | 'week' | 'year'} groupBy Statistics group by
         * @param {'amount' | 'conversion' | 'date' | 'successfullCount' | 'totalCount'} orderBy Statistics order field
         * @param {'asc' | 'desc'} orderDirection Statistics order direction
         * @param {'deposit' | 'transfer'} type Statistics type
         * @param {string} [dateFrom] Statistics from date
         * @param {string} [dateTo] Statistics to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountStatisticsControllerGet(groupBy: 'day' | 'hour' | 'month' | 'week' | 'year', orderBy: 'amount' | 'conversion' | 'date' | 'successfullCount' | 'totalCount', orderDirection: 'asc' | 'desc', type: 'deposit' | 'transfer', dateFrom?: string, dateTo?: string, options?: any): AxiosPromise<AccountStatisticsGetSimpleListResponseDTO> {
            return localVarFp.accountStatisticsControllerGet(groupBy, orderBy, orderDirection, type, dateFrom, dateTo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountStatisticsApi - object-oriented interface
 * @export
 * @class AccountStatisticsApi
 * @extends {BaseAPI}
 */
export class AccountStatisticsApi extends BaseAPI {
    /**
     * This method is used for fetching simple list of `Statisticss`
     * @summary Fetching simple list of `Statisticss`
     * @param {'day' | 'hour' | 'month' | 'week' | 'year'} groupBy Statistics group by
     * @param {'amount' | 'conversion' | 'date' | 'successfullCount' | 'totalCount'} orderBy Statistics order field
     * @param {'asc' | 'desc'} orderDirection Statistics order direction
     * @param {'deposit' | 'transfer'} type Statistics type
     * @param {string} [dateFrom] Statistics from date
     * @param {string} [dateTo] Statistics to date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountStatisticsApi
     */
    public accountStatisticsControllerGet(groupBy: 'day' | 'hour' | 'month' | 'week' | 'year', orderBy: 'amount' | 'conversion' | 'date' | 'successfullCount' | 'totalCount', orderDirection: 'asc' | 'desc', type: 'deposit' | 'transfer', dateFrom?: string, dateTo?: string, options?: AxiosRequestConfig) {
        return AccountStatisticsApiFp(this.configuration).accountStatisticsControllerGet(groupBy, orderBy, orderDirection, type, dateFrom, dateTo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AdminAuthApi - axios parameter creator
 * @export
 */
export const AdminAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This method is used for authentication of `AdminUser`
         * @summary Authentication of `AdminUser`
         * @param {AdminAuthAuthenticationRequestBodyDTO} adminAuthAuthenticationRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAuthControllerAuthentication: async (adminAuthAuthenticationRequestBodyDTO: AdminAuthAuthenticationRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminAuthAuthenticationRequestBodyDTO' is not null or undefined
            assertParamExists('adminAuthControllerAuthentication', 'adminAuthAuthenticationRequestBodyDTO', adminAuthAuthenticationRequestBodyDTO)
            const localVarPath = `/v1/admin/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminAuthAuthenticationRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for refresh of `AdminUser`
         * @summary Refresh of `AdminUser`
         * @param {AdminAuthRefreshRequestBodyDTO} adminAuthRefreshRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAuthControllerRefresh: async (adminAuthRefreshRequestBodyDTO: AdminAuthRefreshRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminAuthRefreshRequestBodyDTO' is not null or undefined
            assertParamExists('adminAuthControllerRefresh', 'adminAuthRefreshRequestBodyDTO', adminAuthRefreshRequestBodyDTO)
            const localVarPath = `/v1/admin/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminAuthRefreshRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminAuthApi - functional programming interface
 * @export
 */
export const AdminAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * This method is used for authentication of `AdminUser`
         * @summary Authentication of `AdminUser`
         * @param {AdminAuthAuthenticationRequestBodyDTO} adminAuthAuthenticationRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminAuthControllerAuthentication(adminAuthAuthenticationRequestBodyDTO: AdminAuthAuthenticationRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminAuthAuthenticationResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminAuthControllerAuthentication(adminAuthAuthenticationRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for refresh of `AdminUser`
         * @summary Refresh of `AdminUser`
         * @param {AdminAuthRefreshRequestBodyDTO} adminAuthRefreshRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminAuthControllerRefresh(adminAuthRefreshRequestBodyDTO: AdminAuthRefreshRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminAuthRefreshResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminAuthControllerRefresh(adminAuthRefreshRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminAuthApi - factory interface
 * @export
 */
export const AdminAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminAuthApiFp(configuration)
    return {
        /**
         * This method is used for authentication of `AdminUser`
         * @summary Authentication of `AdminUser`
         * @param {AdminAuthAuthenticationRequestBodyDTO} adminAuthAuthenticationRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAuthControllerAuthentication(adminAuthAuthenticationRequestBodyDTO: AdminAuthAuthenticationRequestBodyDTO, options?: any): AxiosPromise<AdminAuthAuthenticationResponseDTO> {
            return localVarFp.adminAuthControllerAuthentication(adminAuthAuthenticationRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for refresh of `AdminUser`
         * @summary Refresh of `AdminUser`
         * @param {AdminAuthRefreshRequestBodyDTO} adminAuthRefreshRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAuthControllerRefresh(adminAuthRefreshRequestBodyDTO: AdminAuthRefreshRequestBodyDTO, options?: any): AxiosPromise<AdminAuthRefreshResponseDTO> {
            return localVarFp.adminAuthControllerRefresh(adminAuthRefreshRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminAuthApi - object-oriented interface
 * @export
 * @class AdminAuthApi
 * @extends {BaseAPI}
 */
export class AdminAuthApi extends BaseAPI {
    /**
     * This method is used for authentication of `AdminUser`
     * @summary Authentication of `AdminUser`
     * @param {AdminAuthAuthenticationRequestBodyDTO} adminAuthAuthenticationRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminAuthApi
     */
    public adminAuthControllerAuthentication(adminAuthAuthenticationRequestBodyDTO: AdminAuthAuthenticationRequestBodyDTO, options?: AxiosRequestConfig) {
        return AdminAuthApiFp(this.configuration).adminAuthControllerAuthentication(adminAuthAuthenticationRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for refresh of `AdminUser`
     * @summary Refresh of `AdminUser`
     * @param {AdminAuthRefreshRequestBodyDTO} adminAuthRefreshRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminAuthApi
     */
    public adminAuthControllerRefresh(adminAuthRefreshRequestBodyDTO: AdminAuthRefreshRequestBodyDTO, options?: AxiosRequestConfig) {
        return AdminAuthApiFp(this.configuration).adminAuthControllerRefresh(adminAuthRefreshRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AdminUserApi - axios parameter creator
 * @export
 */
export const AdminUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This method is used for creating `AdminUser`
         * @summary Creating `AdminUser`
         * @param {AdminUserCreateRequestBodyDTO} adminUserCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserControllerCreate: async (adminUserCreateRequestBodyDTO: AdminUserCreateRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminUserCreateRequestBodyDTO' is not null or undefined
            assertParamExists('adminUserControllerCreate', 'adminUserCreateRequestBodyDTO', adminUserCreateRequestBodyDTO)
            const localVarPath = `/v1/admin/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminUserCreateRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for deleting `AdminUser`
         * @summary Deleting `AdminUser`
         * @param {string} user AdminUser identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserControllerDelete: async (user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('adminUserControllerDelete', 'user', user)
            const localVarPath = `/v1/admin/user/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for fetching `AdminUser`
         * @summary Fetching `AdminUser`
         * @param {string} user AdminUser identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserControllerGet: async (user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('adminUserControllerGet', 'user', user)
            const localVarPath = `/v1/admin/user/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for fetching list of `AdminUsers`
         * @summary Fetching list of `AdminUsers`
         * @param {number} limit AdminUserGetResponseDTO Items per page
         * @param {number} page AdminUserGetResponseDTO Page to return
         * @param {'createdAt' | 'login' | 'status' | 'updatedAt'} orderBy AdminUser order field
         * @param {'asc' | 'desc'} orderDirection AdminUser order direction
         * @param {'active' | 'blocked'} [status] AdminUser status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserControllerGetList: async (limit: number, page: number, orderBy: 'createdAt' | 'login' | 'status' | 'updatedAt', orderDirection: 'asc' | 'desc', status?: 'active' | 'blocked', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('adminUserControllerGetList', 'limit', limit)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('adminUserControllerGetList', 'page', page)
            // verify required parameter 'orderBy' is not null or undefined
            assertParamExists('adminUserControllerGetList', 'orderBy', orderBy)
            // verify required parameter 'orderDirection' is not null or undefined
            assertParamExists('adminUserControllerGetList', 'orderDirection', orderDirection)
            const localVarPath = `/v1/admin/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for fetching `AdminUser`
         * @summary Fetching `AdminUser`
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserControllerInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/admin/user/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for partial updating `AdminUser`
         * @summary Partial updating `AdminUser`
         * @param {string} user AdminUser identifier
         * @param {AdminUserPartialUpdateRequestBodyDTO} adminUserPartialUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserControllerPartialUpdate: async (user: string, adminUserPartialUpdateRequestBodyDTO: AdminUserPartialUpdateRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('adminUserControllerPartialUpdate', 'user', user)
            // verify required parameter 'adminUserPartialUpdateRequestBodyDTO' is not null or undefined
            assertParamExists('adminUserControllerPartialUpdate', 'adminUserPartialUpdateRequestBodyDTO', adminUserPartialUpdateRequestBodyDTO)
            const localVarPath = `/v1/admin/user/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminUserPartialUpdateRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for updating `AdminUser`
         * @summary Updating `AdminUser`
         * @param {string} user AdminUser identifier
         * @param {AdminUserUpdateRequestBodyDTO} adminUserUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserControllerUpdate: async (user: string, adminUserUpdateRequestBodyDTO: AdminUserUpdateRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('adminUserControllerUpdate', 'user', user)
            // verify required parameter 'adminUserUpdateRequestBodyDTO' is not null or undefined
            assertParamExists('adminUserControllerUpdate', 'adminUserUpdateRequestBodyDTO', adminUserUpdateRequestBodyDTO)
            const localVarPath = `/v1/admin/user/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminUserUpdateRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminUserApi - functional programming interface
 * @export
 */
export const AdminUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminUserApiAxiosParamCreator(configuration)
    return {
        /**
         * This method is used for creating `AdminUser`
         * @summary Creating `AdminUser`
         * @param {AdminUserCreateRequestBodyDTO} adminUserCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUserControllerCreate(adminUserCreateRequestBodyDTO: AdminUserCreateRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminUserCreateResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUserControllerCreate(adminUserCreateRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for deleting `AdminUser`
         * @summary Deleting `AdminUser`
         * @param {string} user AdminUser identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUserControllerDelete(user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUserControllerDelete(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for fetching `AdminUser`
         * @summary Fetching `AdminUser`
         * @param {string} user AdminUser identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUserControllerGet(user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminUserGetResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUserControllerGet(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for fetching list of `AdminUsers`
         * @summary Fetching list of `AdminUsers`
         * @param {number} limit AdminUserGetResponseDTO Items per page
         * @param {number} page AdminUserGetResponseDTO Page to return
         * @param {'createdAt' | 'login' | 'status' | 'updatedAt'} orderBy AdminUser order field
         * @param {'asc' | 'desc'} orderDirection AdminUser order direction
         * @param {'active' | 'blocked'} [status] AdminUser status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUserControllerGetList(limit: number, page: number, orderBy: 'createdAt' | 'login' | 'status' | 'updatedAt', orderDirection: 'asc' | 'desc', status?: 'active' | 'blocked', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminUserGetListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUserControllerGetList(limit, page, orderBy, orderDirection, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for fetching `AdminUser`
         * @summary Fetching `AdminUser`
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUserControllerInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminUserGetResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUserControllerInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for partial updating `AdminUser`
         * @summary Partial updating `AdminUser`
         * @param {string} user AdminUser identifier
         * @param {AdminUserPartialUpdateRequestBodyDTO} adminUserPartialUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUserControllerPartialUpdate(user: string, adminUserPartialUpdateRequestBodyDTO: AdminUserPartialUpdateRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminUserPartialUpdateResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUserControllerPartialUpdate(user, adminUserPartialUpdateRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for updating `AdminUser`
         * @summary Updating `AdminUser`
         * @param {string} user AdminUser identifier
         * @param {AdminUserUpdateRequestBodyDTO} adminUserUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUserControllerUpdate(user: string, adminUserUpdateRequestBodyDTO: AdminUserUpdateRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminUserUpdateResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUserControllerUpdate(user, adminUserUpdateRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminUserApi - factory interface
 * @export
 */
export const AdminUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminUserApiFp(configuration)
    return {
        /**
         * This method is used for creating `AdminUser`
         * @summary Creating `AdminUser`
         * @param {AdminUserCreateRequestBodyDTO} adminUserCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserControllerCreate(adminUserCreateRequestBodyDTO: AdminUserCreateRequestBodyDTO, options?: any): AxiosPromise<AdminUserCreateResponseDTO> {
            return localVarFp.adminUserControllerCreate(adminUserCreateRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for deleting `AdminUser`
         * @summary Deleting `AdminUser`
         * @param {string} user AdminUser identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserControllerDelete(user: string, options?: any): AxiosPromise<void> {
            return localVarFp.adminUserControllerDelete(user, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for fetching `AdminUser`
         * @summary Fetching `AdminUser`
         * @param {string} user AdminUser identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserControllerGet(user: string, options?: any): AxiosPromise<AdminUserGetResponseDTO> {
            return localVarFp.adminUserControllerGet(user, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for fetching list of `AdminUsers`
         * @summary Fetching list of `AdminUsers`
         * @param {number} limit AdminUserGetResponseDTO Items per page
         * @param {number} page AdminUserGetResponseDTO Page to return
         * @param {'createdAt' | 'login' | 'status' | 'updatedAt'} orderBy AdminUser order field
         * @param {'asc' | 'desc'} orderDirection AdminUser order direction
         * @param {'active' | 'blocked'} [status] AdminUser status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserControllerGetList(limit: number, page: number, orderBy: 'createdAt' | 'login' | 'status' | 'updatedAt', orderDirection: 'asc' | 'desc', status?: 'active' | 'blocked', options?: any): AxiosPromise<AdminUserGetListResponseDTO> {
            return localVarFp.adminUserControllerGetList(limit, page, orderBy, orderDirection, status, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for fetching `AdminUser`
         * @summary Fetching `AdminUser`
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserControllerInfo(options?: any): AxiosPromise<AdminUserGetResponseDTO> {
            return localVarFp.adminUserControllerInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for partial updating `AdminUser`
         * @summary Partial updating `AdminUser`
         * @param {string} user AdminUser identifier
         * @param {AdminUserPartialUpdateRequestBodyDTO} adminUserPartialUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserControllerPartialUpdate(user: string, adminUserPartialUpdateRequestBodyDTO: AdminUserPartialUpdateRequestBodyDTO, options?: any): AxiosPromise<AdminUserPartialUpdateResponseDTO> {
            return localVarFp.adminUserControllerPartialUpdate(user, adminUserPartialUpdateRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for updating `AdminUser`
         * @summary Updating `AdminUser`
         * @param {string} user AdminUser identifier
         * @param {AdminUserUpdateRequestBodyDTO} adminUserUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserControllerUpdate(user: string, adminUserUpdateRequestBodyDTO: AdminUserUpdateRequestBodyDTO, options?: any): AxiosPromise<AdminUserUpdateResponseDTO> {
            return localVarFp.adminUserControllerUpdate(user, adminUserUpdateRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminUserApi - object-oriented interface
 * @export
 * @class AdminUserApi
 * @extends {BaseAPI}
 */
export class AdminUserApi extends BaseAPI {
    /**
     * This method is used for creating `AdminUser`
     * @summary Creating `AdminUser`
     * @param {AdminUserCreateRequestBodyDTO} adminUserCreateRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUserApi
     */
    public adminUserControllerCreate(adminUserCreateRequestBodyDTO: AdminUserCreateRequestBodyDTO, options?: AxiosRequestConfig) {
        return AdminUserApiFp(this.configuration).adminUserControllerCreate(adminUserCreateRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for deleting `AdminUser`
     * @summary Deleting `AdminUser`
     * @param {string} user AdminUser identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUserApi
     */
    public adminUserControllerDelete(user: string, options?: AxiosRequestConfig) {
        return AdminUserApiFp(this.configuration).adminUserControllerDelete(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for fetching `AdminUser`
     * @summary Fetching `AdminUser`
     * @param {string} user AdminUser identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUserApi
     */
    public adminUserControllerGet(user: string, options?: AxiosRequestConfig) {
        return AdminUserApiFp(this.configuration).adminUserControllerGet(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for fetching list of `AdminUsers`
     * @summary Fetching list of `AdminUsers`
     * @param {number} limit AdminUserGetResponseDTO Items per page
     * @param {number} page AdminUserGetResponseDTO Page to return
     * @param {'createdAt' | 'login' | 'status' | 'updatedAt'} orderBy AdminUser order field
     * @param {'asc' | 'desc'} orderDirection AdminUser order direction
     * @param {'active' | 'blocked'} [status] AdminUser status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUserApi
     */
    public adminUserControllerGetList(limit: number, page: number, orderBy: 'createdAt' | 'login' | 'status' | 'updatedAt', orderDirection: 'asc' | 'desc', status?: 'active' | 'blocked', options?: AxiosRequestConfig) {
        return AdminUserApiFp(this.configuration).adminUserControllerGetList(limit, page, orderBy, orderDirection, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for fetching `AdminUser`
     * @summary Fetching `AdminUser`
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUserApi
     */
    public adminUserControllerInfo(options?: AxiosRequestConfig) {
        return AdminUserApiFp(this.configuration).adminUserControllerInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for partial updating `AdminUser`
     * @summary Partial updating `AdminUser`
     * @param {string} user AdminUser identifier
     * @param {AdminUserPartialUpdateRequestBodyDTO} adminUserPartialUpdateRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUserApi
     */
    public adminUserControllerPartialUpdate(user: string, adminUserPartialUpdateRequestBodyDTO: AdminUserPartialUpdateRequestBodyDTO, options?: AxiosRequestConfig) {
        return AdminUserApiFp(this.configuration).adminUserControllerPartialUpdate(user, adminUserPartialUpdateRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for updating `AdminUser`
     * @summary Updating `AdminUser`
     * @param {string} user AdminUser identifier
     * @param {AdminUserUpdateRequestBodyDTO} adminUserUpdateRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUserApi
     */
    public adminUserControllerUpdate(user: string, adminUserUpdateRequestBodyDTO: AdminUserUpdateRequestBodyDTO, options?: AxiosRequestConfig) {
        return AdminUserApiFp(this.configuration).adminUserControllerUpdate(user, adminUserUpdateRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This method is used for authentication of `User`
         * @summary Authentication of `User`
         * @param {AdminAuthAuthenticationRequestBodyDTO} adminAuthAuthenticationRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerAuthentication: async (adminAuthAuthenticationRequestBodyDTO: AdminAuthAuthenticationRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminAuthAuthenticationRequestBodyDTO' is not null or undefined
            assertParamExists('authControllerAuthentication', 'adminAuthAuthenticationRequestBodyDTO', adminAuthAuthenticationRequestBodyDTO)
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminAuthAuthenticationRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for refresh of `User`
         * @summary Refresh of `User`
         * @param {AuthRefreshRequestBodyDTO} authRefreshRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefresh: async (authRefreshRequestBodyDTO: AuthRefreshRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authRefreshRequestBodyDTO' is not null or undefined
            assertParamExists('authControllerRefresh', 'authRefreshRequestBodyDTO', authRefreshRequestBodyDTO)
            const localVarPath = `/v1/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRefreshRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * This method is used for authentication of `User`
         * @summary Authentication of `User`
         * @param {AdminAuthAuthenticationRequestBodyDTO} adminAuthAuthenticationRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerAuthentication(adminAuthAuthenticationRequestBodyDTO: AdminAuthAuthenticationRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthAuthenticationResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerAuthentication(adminAuthAuthenticationRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for refresh of `User`
         * @summary Refresh of `User`
         * @param {AuthRefreshRequestBodyDTO} authRefreshRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRefresh(authRefreshRequestBodyDTO: AuthRefreshRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthRefreshResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRefresh(authRefreshRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * This method is used for authentication of `User`
         * @summary Authentication of `User`
         * @param {AdminAuthAuthenticationRequestBodyDTO} adminAuthAuthenticationRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerAuthentication(adminAuthAuthenticationRequestBodyDTO: AdminAuthAuthenticationRequestBodyDTO, options?: any): AxiosPromise<AuthAuthenticationResponseDTO> {
            return localVarFp.authControllerAuthentication(adminAuthAuthenticationRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for refresh of `User`
         * @summary Refresh of `User`
         * @param {AuthRefreshRequestBodyDTO} authRefreshRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefresh(authRefreshRequestBodyDTO: AuthRefreshRequestBodyDTO, options?: any): AxiosPromise<AuthRefreshResponseDTO> {
            return localVarFp.authControllerRefresh(authRefreshRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * This method is used for authentication of `User`
     * @summary Authentication of `User`
     * @param {AdminAuthAuthenticationRequestBodyDTO} adminAuthAuthenticationRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerAuthentication(adminAuthAuthenticationRequestBodyDTO: AdminAuthAuthenticationRequestBodyDTO, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerAuthentication(adminAuthAuthenticationRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for refresh of `User`
     * @summary Refresh of `User`
     * @param {AuthRefreshRequestBodyDTO} authRefreshRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerRefresh(authRefreshRequestBodyDTO: AuthRefreshRequestBodyDTO, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerRefresh(authRefreshRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BankApi - axios parameter creator
 * @export
 */
export const BankApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This method is used for creating `Bank`
         * @summary Creating `Bank`
         * @param {BankCreateRequestBodyDTO} bankCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankControllerCreate: async (bankCreateRequestBodyDTO: BankCreateRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankCreateRequestBodyDTO' is not null or undefined
            assertParamExists('bankControllerCreate', 'bankCreateRequestBodyDTO', bankCreateRequestBodyDTO)
            const localVarPath = `/v1/bank`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bankCreateRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for deleting `Bank`
         * @summary Deleting `Bank`
         * @param {string} bank Bank identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankControllerDelete: async (bank: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bank' is not null or undefined
            assertParamExists('bankControllerDelete', 'bank', bank)
            const localVarPath = `/v1/bank/{bank}`
                .replace(`{${"bank"}}`, encodeURIComponent(String(bank)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for fetching `Bank`
         * @summary Fetching `Bank`
         * @param {string} bank Bank identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankControllerGet: async (bank: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bank' is not null or undefined
            assertParamExists('bankControllerGet', 'bank', bank)
            const localVarPath = `/v1/bank/{bank}`
                .replace(`{${"bank"}}`, encodeURIComponent(String(bank)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for fetching list of `Banks`
         * @summary Fetching list of `Banks`
         * @param {number} limit BankGetResponseDTO Items per page
         * @param {number} page BankGetResponseDTO Page to return
         * @param {'createdAt' | 'updatedAt'} orderBy Bank order field
         * @param {'asc' | 'desc'} orderDirection Bank order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankControllerGetList: async (limit: number, page: number, orderBy: 'createdAt' | 'updatedAt', orderDirection: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('bankControllerGetList', 'limit', limit)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('bankControllerGetList', 'page', page)
            // verify required parameter 'orderBy' is not null or undefined
            assertParamExists('bankControllerGetList', 'orderBy', orderBy)
            // verify required parameter 'orderDirection' is not null or undefined
            assertParamExists('bankControllerGetList', 'orderDirection', orderDirection)
            const localVarPath = `/v1/bank`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for updating `Bank`
         * @summary Updating `Bank`
         * @param {string} bank Bank identifier
         * @param {BankPartialUpdateRequestBodyDTO} bankPartialUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankControllerPartialUpdate: async (bank: string, bankPartialUpdateRequestBodyDTO: BankPartialUpdateRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bank' is not null or undefined
            assertParamExists('bankControllerPartialUpdate', 'bank', bank)
            // verify required parameter 'bankPartialUpdateRequestBodyDTO' is not null or undefined
            assertParamExists('bankControllerPartialUpdate', 'bankPartialUpdateRequestBodyDTO', bankPartialUpdateRequestBodyDTO)
            const localVarPath = `/v1/bank/{bank}`
                .replace(`{${"bank"}}`, encodeURIComponent(String(bank)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bankPartialUpdateRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for updating `Bank`
         * @summary Updating `Bank`
         * @param {string} bank Bank identifier
         * @param {BankUpdateRequestBodyDTO} bankUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankControllerUpdate: async (bank: string, bankUpdateRequestBodyDTO: BankUpdateRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bank' is not null or undefined
            assertParamExists('bankControllerUpdate', 'bank', bank)
            // verify required parameter 'bankUpdateRequestBodyDTO' is not null or undefined
            assertParamExists('bankControllerUpdate', 'bankUpdateRequestBodyDTO', bankUpdateRequestBodyDTO)
            const localVarPath = `/v1/bank/{bank}`
                .replace(`{${"bank"}}`, encodeURIComponent(String(bank)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bankUpdateRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankApi - functional programming interface
 * @export
 */
export const BankApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BankApiAxiosParamCreator(configuration)
    return {
        /**
         * This method is used for creating `Bank`
         * @summary Creating `Bank`
         * @param {BankCreateRequestBodyDTO} bankCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankControllerCreate(bankCreateRequestBodyDTO: BankCreateRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankCreateResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankControllerCreate(bankCreateRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for deleting `Bank`
         * @summary Deleting `Bank`
         * @param {string} bank Bank identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankControllerDelete(bank: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankControllerDelete(bank, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for fetching `Bank`
         * @summary Fetching `Bank`
         * @param {string} bank Bank identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankControllerGet(bank: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankGetResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankControllerGet(bank, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for fetching list of `Banks`
         * @summary Fetching list of `Banks`
         * @param {number} limit BankGetResponseDTO Items per page
         * @param {number} page BankGetResponseDTO Page to return
         * @param {'createdAt' | 'updatedAt'} orderBy Bank order field
         * @param {'asc' | 'desc'} orderDirection Bank order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankControllerGetList(limit: number, page: number, orderBy: 'createdAt' | 'updatedAt', orderDirection: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankGetListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankControllerGetList(limit, page, orderBy, orderDirection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for updating `Bank`
         * @summary Updating `Bank`
         * @param {string} bank Bank identifier
         * @param {BankPartialUpdateRequestBodyDTO} bankPartialUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankControllerPartialUpdate(bank: string, bankPartialUpdateRequestBodyDTO: BankPartialUpdateRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankPartialUpdateResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankControllerPartialUpdate(bank, bankPartialUpdateRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for updating `Bank`
         * @summary Updating `Bank`
         * @param {string} bank Bank identifier
         * @param {BankUpdateRequestBodyDTO} bankUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankControllerUpdate(bank: string, bankUpdateRequestBodyDTO: BankUpdateRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankUpdateResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankControllerUpdate(bank, bankUpdateRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BankApi - factory interface
 * @export
 */
export const BankApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BankApiFp(configuration)
    return {
        /**
         * This method is used for creating `Bank`
         * @summary Creating `Bank`
         * @param {BankCreateRequestBodyDTO} bankCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankControllerCreate(bankCreateRequestBodyDTO: BankCreateRequestBodyDTO, options?: any): AxiosPromise<BankCreateResponseDTO> {
            return localVarFp.bankControllerCreate(bankCreateRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for deleting `Bank`
         * @summary Deleting `Bank`
         * @param {string} bank Bank identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankControllerDelete(bank: string, options?: any): AxiosPromise<void> {
            return localVarFp.bankControllerDelete(bank, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for fetching `Bank`
         * @summary Fetching `Bank`
         * @param {string} bank Bank identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankControllerGet(bank: string, options?: any): AxiosPromise<BankGetResponseDTO> {
            return localVarFp.bankControllerGet(bank, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for fetching list of `Banks`
         * @summary Fetching list of `Banks`
         * @param {number} limit BankGetResponseDTO Items per page
         * @param {number} page BankGetResponseDTO Page to return
         * @param {'createdAt' | 'updatedAt'} orderBy Bank order field
         * @param {'asc' | 'desc'} orderDirection Bank order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankControllerGetList(limit: number, page: number, orderBy: 'createdAt' | 'updatedAt', orderDirection: 'asc' | 'desc', options?: any): AxiosPromise<BankGetListResponseDTO> {
            return localVarFp.bankControllerGetList(limit, page, orderBy, orderDirection, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for updating `Bank`
         * @summary Updating `Bank`
         * @param {string} bank Bank identifier
         * @param {BankPartialUpdateRequestBodyDTO} bankPartialUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankControllerPartialUpdate(bank: string, bankPartialUpdateRequestBodyDTO: BankPartialUpdateRequestBodyDTO, options?: any): AxiosPromise<BankPartialUpdateResponseDTO> {
            return localVarFp.bankControllerPartialUpdate(bank, bankPartialUpdateRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for updating `Bank`
         * @summary Updating `Bank`
         * @param {string} bank Bank identifier
         * @param {BankUpdateRequestBodyDTO} bankUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankControllerUpdate(bank: string, bankUpdateRequestBodyDTO: BankUpdateRequestBodyDTO, options?: any): AxiosPromise<BankUpdateResponseDTO> {
            return localVarFp.bankControllerUpdate(bank, bankUpdateRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BankApi - object-oriented interface
 * @export
 * @class BankApi
 * @extends {BaseAPI}
 */
export class BankApi extends BaseAPI {
    /**
     * This method is used for creating `Bank`
     * @summary Creating `Bank`
     * @param {BankCreateRequestBodyDTO} bankCreateRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankApi
     */
    public bankControllerCreate(bankCreateRequestBodyDTO: BankCreateRequestBodyDTO, options?: AxiosRequestConfig) {
        return BankApiFp(this.configuration).bankControllerCreate(bankCreateRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for deleting `Bank`
     * @summary Deleting `Bank`
     * @param {string} bank Bank identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankApi
     */
    public bankControllerDelete(bank: string, options?: AxiosRequestConfig) {
        return BankApiFp(this.configuration).bankControllerDelete(bank, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for fetching `Bank`
     * @summary Fetching `Bank`
     * @param {string} bank Bank identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankApi
     */
    public bankControllerGet(bank: string, options?: AxiosRequestConfig) {
        return BankApiFp(this.configuration).bankControllerGet(bank, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for fetching list of `Banks`
     * @summary Fetching list of `Banks`
     * @param {number} limit BankGetResponseDTO Items per page
     * @param {number} page BankGetResponseDTO Page to return
     * @param {'createdAt' | 'updatedAt'} orderBy Bank order field
     * @param {'asc' | 'desc'} orderDirection Bank order direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankApi
     */
    public bankControllerGetList(limit: number, page: number, orderBy: 'createdAt' | 'updatedAt', orderDirection: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return BankApiFp(this.configuration).bankControllerGetList(limit, page, orderBy, orderDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for updating `Bank`
     * @summary Updating `Bank`
     * @param {string} bank Bank identifier
     * @param {BankPartialUpdateRequestBodyDTO} bankPartialUpdateRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankApi
     */
    public bankControllerPartialUpdate(bank: string, bankPartialUpdateRequestBodyDTO: BankPartialUpdateRequestBodyDTO, options?: AxiosRequestConfig) {
        return BankApiFp(this.configuration).bankControllerPartialUpdate(bank, bankPartialUpdateRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for updating `Bank`
     * @summary Updating `Bank`
     * @param {string} bank Bank identifier
     * @param {BankUpdateRequestBodyDTO} bankUpdateRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankApi
     */
    public bankControllerUpdate(bank: string, bankUpdateRequestBodyDTO: BankUpdateRequestBodyDTO, options?: AxiosRequestConfig) {
        return BankApiFp(this.configuration).bankControllerUpdate(bank, bankUpdateRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConfigSectionApi - axios parameter creator
 * @export
 */
export const ConfigSectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This method is used for creating `ConfigSection`
         * @summary Creating `ConfigSection`
         * @param {ConfigSectionCreateRequestBodyDTO} configSectionCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configSectionControllerCreate: async (configSectionCreateRequestBodyDTO: ConfigSectionCreateRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configSectionCreateRequestBodyDTO' is not null or undefined
            assertParamExists('configSectionControllerCreate', 'configSectionCreateRequestBodyDTO', configSectionCreateRequestBodyDTO)
            const localVarPath = `/v1/config/section`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configSectionCreateRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for deleting `ConfigSection`
         * @summary Deleting `ConfigSection`
         * @param {string} section ConfigSection identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configSectionControllerDelete: async (section: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'section' is not null or undefined
            assertParamExists('configSectionControllerDelete', 'section', section)
            const localVarPath = `/v1/config/section/{section}`
                .replace(`{${"section"}}`, encodeURIComponent(String(section)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for fetching `ConfigSection`
         * @summary Fetching `ConfigSection`
         * @param {string} section ConfigSection identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configSectionControllerGet: async (section: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'section' is not null or undefined
            assertParamExists('configSectionControllerGet', 'section', section)
            const localVarPath = `/v1/config/section/{section}`
                .replace(`{${"section"}}`, encodeURIComponent(String(section)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for fetching list of `ConfigSections`
         * @summary Fetching list of `ConfigSections`
         * @param {number} limit ConfigSectionGetResponseDTO Items per page
         * @param {number} page ConfigSectionGetResponseDTO Page to return
         * @param {'createdAt' | 'name' | 'updatedAt'} orderBy ConfigSection order field
         * @param {'asc' | 'desc'} orderDirection ConfigSection order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configSectionControllerGetList: async (limit: number, page: number, orderBy: 'createdAt' | 'name' | 'updatedAt', orderDirection: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('configSectionControllerGetList', 'limit', limit)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('configSectionControllerGetList', 'page', page)
            // verify required parameter 'orderBy' is not null or undefined
            assertParamExists('configSectionControllerGetList', 'orderBy', orderBy)
            // verify required parameter 'orderDirection' is not null or undefined
            assertParamExists('configSectionControllerGetList', 'orderDirection', orderDirection)
            const localVarPath = `/v1/config/section`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for updating `ConfigSection`
         * @summary Updating `ConfigSection`
         * @param {string} section ConfigSection identifier
         * @param {ConfigSectionUpdateRequestBodyDTO} configSectionUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configSectionControllerUpdate: async (section: string, configSectionUpdateRequestBodyDTO: ConfigSectionUpdateRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'section' is not null or undefined
            assertParamExists('configSectionControllerUpdate', 'section', section)
            // verify required parameter 'configSectionUpdateRequestBodyDTO' is not null or undefined
            assertParamExists('configSectionControllerUpdate', 'configSectionUpdateRequestBodyDTO', configSectionUpdateRequestBodyDTO)
            const localVarPath = `/v1/config/section/{section}`
                .replace(`{${"section"}}`, encodeURIComponent(String(section)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configSectionUpdateRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigSectionApi - functional programming interface
 * @export
 */
export const ConfigSectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigSectionApiAxiosParamCreator(configuration)
    return {
        /**
         * This method is used for creating `ConfigSection`
         * @summary Creating `ConfigSection`
         * @param {ConfigSectionCreateRequestBodyDTO} configSectionCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configSectionControllerCreate(configSectionCreateRequestBodyDTO: ConfigSectionCreateRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigSectionCreateResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configSectionControllerCreate(configSectionCreateRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for deleting `ConfigSection`
         * @summary Deleting `ConfigSection`
         * @param {string} section ConfigSection identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configSectionControllerDelete(section: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configSectionControllerDelete(section, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for fetching `ConfigSection`
         * @summary Fetching `ConfigSection`
         * @param {string} section ConfigSection identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configSectionControllerGet(section: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigSectionGetResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configSectionControllerGet(section, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for fetching list of `ConfigSections`
         * @summary Fetching list of `ConfigSections`
         * @param {number} limit ConfigSectionGetResponseDTO Items per page
         * @param {number} page ConfigSectionGetResponseDTO Page to return
         * @param {'createdAt' | 'name' | 'updatedAt'} orderBy ConfigSection order field
         * @param {'asc' | 'desc'} orderDirection ConfigSection order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configSectionControllerGetList(limit: number, page: number, orderBy: 'createdAt' | 'name' | 'updatedAt', orderDirection: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigSectionGetListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configSectionControllerGetList(limit, page, orderBy, orderDirection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for updating `ConfigSection`
         * @summary Updating `ConfigSection`
         * @param {string} section ConfigSection identifier
         * @param {ConfigSectionUpdateRequestBodyDTO} configSectionUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configSectionControllerUpdate(section: string, configSectionUpdateRequestBodyDTO: ConfigSectionUpdateRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigSectionUpdateResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configSectionControllerUpdate(section, configSectionUpdateRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConfigSectionApi - factory interface
 * @export
 */
export const ConfigSectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigSectionApiFp(configuration)
    return {
        /**
         * This method is used for creating `ConfigSection`
         * @summary Creating `ConfigSection`
         * @param {ConfigSectionCreateRequestBodyDTO} configSectionCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configSectionControllerCreate(configSectionCreateRequestBodyDTO: ConfigSectionCreateRequestBodyDTO, options?: any): AxiosPromise<ConfigSectionCreateResponseDTO> {
            return localVarFp.configSectionControllerCreate(configSectionCreateRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for deleting `ConfigSection`
         * @summary Deleting `ConfigSection`
         * @param {string} section ConfigSection identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configSectionControllerDelete(section: string, options?: any): AxiosPromise<void> {
            return localVarFp.configSectionControllerDelete(section, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for fetching `ConfigSection`
         * @summary Fetching `ConfigSection`
         * @param {string} section ConfigSection identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configSectionControllerGet(section: string, options?: any): AxiosPromise<ConfigSectionGetResponseDTO> {
            return localVarFp.configSectionControllerGet(section, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for fetching list of `ConfigSections`
         * @summary Fetching list of `ConfigSections`
         * @param {number} limit ConfigSectionGetResponseDTO Items per page
         * @param {number} page ConfigSectionGetResponseDTO Page to return
         * @param {'createdAt' | 'name' | 'updatedAt'} orderBy ConfigSection order field
         * @param {'asc' | 'desc'} orderDirection ConfigSection order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configSectionControllerGetList(limit: number, page: number, orderBy: 'createdAt' | 'name' | 'updatedAt', orderDirection: 'asc' | 'desc', options?: any): AxiosPromise<ConfigSectionGetListResponseDTO> {
            return localVarFp.configSectionControllerGetList(limit, page, orderBy, orderDirection, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for updating `ConfigSection`
         * @summary Updating `ConfigSection`
         * @param {string} section ConfigSection identifier
         * @param {ConfigSectionUpdateRequestBodyDTO} configSectionUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configSectionControllerUpdate(section: string, configSectionUpdateRequestBodyDTO: ConfigSectionUpdateRequestBodyDTO, options?: any): AxiosPromise<ConfigSectionUpdateResponseDTO> {
            return localVarFp.configSectionControllerUpdate(section, configSectionUpdateRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfigSectionApi - object-oriented interface
 * @export
 * @class ConfigSectionApi
 * @extends {BaseAPI}
 */
export class ConfigSectionApi extends BaseAPI {
    /**
     * This method is used for creating `ConfigSection`
     * @summary Creating `ConfigSection`
     * @param {ConfigSectionCreateRequestBodyDTO} configSectionCreateRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigSectionApi
     */
    public configSectionControllerCreate(configSectionCreateRequestBodyDTO: ConfigSectionCreateRequestBodyDTO, options?: AxiosRequestConfig) {
        return ConfigSectionApiFp(this.configuration).configSectionControllerCreate(configSectionCreateRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for deleting `ConfigSection`
     * @summary Deleting `ConfigSection`
     * @param {string} section ConfigSection identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigSectionApi
     */
    public configSectionControllerDelete(section: string, options?: AxiosRequestConfig) {
        return ConfigSectionApiFp(this.configuration).configSectionControllerDelete(section, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for fetching `ConfigSection`
     * @summary Fetching `ConfigSection`
     * @param {string} section ConfigSection identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigSectionApi
     */
    public configSectionControllerGet(section: string, options?: AxiosRequestConfig) {
        return ConfigSectionApiFp(this.configuration).configSectionControllerGet(section, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for fetching list of `ConfigSections`
     * @summary Fetching list of `ConfigSections`
     * @param {number} limit ConfigSectionGetResponseDTO Items per page
     * @param {number} page ConfigSectionGetResponseDTO Page to return
     * @param {'createdAt' | 'name' | 'updatedAt'} orderBy ConfigSection order field
     * @param {'asc' | 'desc'} orderDirection ConfigSection order direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigSectionApi
     */
    public configSectionControllerGetList(limit: number, page: number, orderBy: 'createdAt' | 'name' | 'updatedAt', orderDirection: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return ConfigSectionApiFp(this.configuration).configSectionControllerGetList(limit, page, orderBy, orderDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for updating `ConfigSection`
     * @summary Updating `ConfigSection`
     * @param {string} section ConfigSection identifier
     * @param {ConfigSectionUpdateRequestBodyDTO} configSectionUpdateRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigSectionApi
     */
    public configSectionControllerUpdate(section: string, configSectionUpdateRequestBodyDTO: ConfigSectionUpdateRequestBodyDTO, options?: AxiosRequestConfig) {
        return ConfigSectionApiFp(this.configuration).configSectionControllerUpdate(section, configSectionUpdateRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConfigSectionDataApi - axios parameter creator
 * @export
 */
export const ConfigSectionDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This method is used for creating `ConfigSectionData`
         * @summary Creating `ConfigSectionData`
         * @param {string} section ConfigSectionData identifier
         * @param {ConfigSectionDataCreateRequestBodyDTO} configSectionDataCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configSectionDataControllerCreate: async (section: string, configSectionDataCreateRequestBodyDTO: ConfigSectionDataCreateRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'section' is not null or undefined
            assertParamExists('configSectionDataControllerCreate', 'section', section)
            // verify required parameter 'configSectionDataCreateRequestBodyDTO' is not null or undefined
            assertParamExists('configSectionDataControllerCreate', 'configSectionDataCreateRequestBodyDTO', configSectionDataCreateRequestBodyDTO)
            const localVarPath = `/v1/config/section/{section}/data`
                .replace(`{${"section"}}`, encodeURIComponent(String(section)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configSectionDataCreateRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for deleting `ConfigSectionData`
         * @summary Deleting `ConfigSectionData`
         * @param {string} data ConfigSectionData identifier
         * @param {string} section ConfigSectionData identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configSectionDataControllerDelete: async (data: string, section: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('configSectionDataControllerDelete', 'data', data)
            // verify required parameter 'section' is not null or undefined
            assertParamExists('configSectionDataControllerDelete', 'section', section)
            const localVarPath = `/v1/config/section/{section}/data/{data}`
                .replace(`{${"data"}}`, encodeURIComponent(String(data)))
                .replace(`{${"section"}}`, encodeURIComponent(String(section)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for fetching `ConfigSectionData`
         * @summary Fetching `ConfigSectionData`
         * @param {string} data ConfigSectionData identifier
         * @param {string} section ConfigSectionData identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configSectionDataControllerGet: async (data: string, section: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('configSectionDataControllerGet', 'data', data)
            // verify required parameter 'section' is not null or undefined
            assertParamExists('configSectionDataControllerGet', 'section', section)
            const localVarPath = `/v1/config/section/{section}/data/{data}`
                .replace(`{${"data"}}`, encodeURIComponent(String(data)))
                .replace(`{${"section"}}`, encodeURIComponent(String(section)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for fetching list of `ConfigSectionDatas`
         * @summary Fetching list of `ConfigSectionDatas`
         * @param {number} limit ConfigSectionDataGetResponseDTO Items per page
         * @param {number} page ConfigSectionDataGetResponseDTO Page to return
         * @param {'createdAt' | 'key' | 'section' | 'updatedAt' | 'value'} orderBy ConfigSectionData order field
         * @param {'asc' | 'desc'} orderDirection ConfigSectionData order direction
         * @param {string} section ConfigSectionData identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configSectionDataControllerGetList: async (limit: number, page: number, orderBy: 'createdAt' | 'key' | 'section' | 'updatedAt' | 'value', orderDirection: 'asc' | 'desc', section: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('configSectionDataControllerGetList', 'limit', limit)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('configSectionDataControllerGetList', 'page', page)
            // verify required parameter 'orderBy' is not null or undefined
            assertParamExists('configSectionDataControllerGetList', 'orderBy', orderBy)
            // verify required parameter 'orderDirection' is not null or undefined
            assertParamExists('configSectionDataControllerGetList', 'orderDirection', orderDirection)
            // verify required parameter 'section' is not null or undefined
            assertParamExists('configSectionDataControllerGetList', 'section', section)
            const localVarPath = `/v1/config/section/{section}/data`
                .replace(`{${"section"}}`, encodeURIComponent(String(section)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for partial updating `ConfigSectionData`
         * @summary Partial updating `ConfigSectionData`
         * @param {string} data ConfigSectionData identifier
         * @param {string} section ConfigSectionData identifier
         * @param {ConfigSectionDataPartialUpdateRequestBodyDTO} configSectionDataPartialUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configSectionDataControllerPartialUpdate: async (data: string, section: string, configSectionDataPartialUpdateRequestBodyDTO: ConfigSectionDataPartialUpdateRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('configSectionDataControllerPartialUpdate', 'data', data)
            // verify required parameter 'section' is not null or undefined
            assertParamExists('configSectionDataControllerPartialUpdate', 'section', section)
            // verify required parameter 'configSectionDataPartialUpdateRequestBodyDTO' is not null or undefined
            assertParamExists('configSectionDataControllerPartialUpdate', 'configSectionDataPartialUpdateRequestBodyDTO', configSectionDataPartialUpdateRequestBodyDTO)
            const localVarPath = `/v1/config/section/{section}/data/{data}`
                .replace(`{${"data"}}`, encodeURIComponent(String(data)))
                .replace(`{${"section"}}`, encodeURIComponent(String(section)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configSectionDataPartialUpdateRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for updating `ConfigSectionData`
         * @summary Updating `ConfigSectionData`
         * @param {string} data ConfigSectionData identifier
         * @param {string} section ConfigSectionData identifier
         * @param {ConfigSectionDataUpdateRequestBodyDTO} configSectionDataUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configSectionDataControllerUpdate: async (data: string, section: string, configSectionDataUpdateRequestBodyDTO: ConfigSectionDataUpdateRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('configSectionDataControllerUpdate', 'data', data)
            // verify required parameter 'section' is not null or undefined
            assertParamExists('configSectionDataControllerUpdate', 'section', section)
            // verify required parameter 'configSectionDataUpdateRequestBodyDTO' is not null or undefined
            assertParamExists('configSectionDataControllerUpdate', 'configSectionDataUpdateRequestBodyDTO', configSectionDataUpdateRequestBodyDTO)
            const localVarPath = `/v1/config/section/{section}/data/{data}`
                .replace(`{${"data"}}`, encodeURIComponent(String(data)))
                .replace(`{${"section"}}`, encodeURIComponent(String(section)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configSectionDataUpdateRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigSectionDataApi - functional programming interface
 * @export
 */
export const ConfigSectionDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigSectionDataApiAxiosParamCreator(configuration)
    return {
        /**
         * This method is used for creating `ConfigSectionData`
         * @summary Creating `ConfigSectionData`
         * @param {string} section ConfigSectionData identifier
         * @param {ConfigSectionDataCreateRequestBodyDTO} configSectionDataCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configSectionDataControllerCreate(section: string, configSectionDataCreateRequestBodyDTO: ConfigSectionDataCreateRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigSectionDataCreateResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configSectionDataControllerCreate(section, configSectionDataCreateRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for deleting `ConfigSectionData`
         * @summary Deleting `ConfigSectionData`
         * @param {string} data ConfigSectionData identifier
         * @param {string} section ConfigSectionData identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configSectionDataControllerDelete(data: string, section: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configSectionDataControllerDelete(data, section, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for fetching `ConfigSectionData`
         * @summary Fetching `ConfigSectionData`
         * @param {string} data ConfigSectionData identifier
         * @param {string} section ConfigSectionData identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configSectionDataControllerGet(data: string, section: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigSectionDataGetResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configSectionDataControllerGet(data, section, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for fetching list of `ConfigSectionDatas`
         * @summary Fetching list of `ConfigSectionDatas`
         * @param {number} limit ConfigSectionDataGetResponseDTO Items per page
         * @param {number} page ConfigSectionDataGetResponseDTO Page to return
         * @param {'createdAt' | 'key' | 'section' | 'updatedAt' | 'value'} orderBy ConfigSectionData order field
         * @param {'asc' | 'desc'} orderDirection ConfigSectionData order direction
         * @param {string} section ConfigSectionData identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configSectionDataControllerGetList(limit: number, page: number, orderBy: 'createdAt' | 'key' | 'section' | 'updatedAt' | 'value', orderDirection: 'asc' | 'desc', section: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigSectionDataGetListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configSectionDataControllerGetList(limit, page, orderBy, orderDirection, section, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for partial updating `ConfigSectionData`
         * @summary Partial updating `ConfigSectionData`
         * @param {string} data ConfigSectionData identifier
         * @param {string} section ConfigSectionData identifier
         * @param {ConfigSectionDataPartialUpdateRequestBodyDTO} configSectionDataPartialUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configSectionDataControllerPartialUpdate(data: string, section: string, configSectionDataPartialUpdateRequestBodyDTO: ConfigSectionDataPartialUpdateRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigSectionDataPartialUpdateResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configSectionDataControllerPartialUpdate(data, section, configSectionDataPartialUpdateRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for updating `ConfigSectionData`
         * @summary Updating `ConfigSectionData`
         * @param {string} data ConfigSectionData identifier
         * @param {string} section ConfigSectionData identifier
         * @param {ConfigSectionDataUpdateRequestBodyDTO} configSectionDataUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configSectionDataControllerUpdate(data: string, section: string, configSectionDataUpdateRequestBodyDTO: ConfigSectionDataUpdateRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigSectionDataUpdateResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configSectionDataControllerUpdate(data, section, configSectionDataUpdateRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConfigSectionDataApi - factory interface
 * @export
 */
export const ConfigSectionDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigSectionDataApiFp(configuration)
    return {
        /**
         * This method is used for creating `ConfigSectionData`
         * @summary Creating `ConfigSectionData`
         * @param {string} section ConfigSectionData identifier
         * @param {ConfigSectionDataCreateRequestBodyDTO} configSectionDataCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configSectionDataControllerCreate(section: string, configSectionDataCreateRequestBodyDTO: ConfigSectionDataCreateRequestBodyDTO, options?: any): AxiosPromise<ConfigSectionDataCreateResponseDTO> {
            return localVarFp.configSectionDataControllerCreate(section, configSectionDataCreateRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for deleting `ConfigSectionData`
         * @summary Deleting `ConfigSectionData`
         * @param {string} data ConfigSectionData identifier
         * @param {string} section ConfigSectionData identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configSectionDataControllerDelete(data: string, section: string, options?: any): AxiosPromise<void> {
            return localVarFp.configSectionDataControllerDelete(data, section, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for fetching `ConfigSectionData`
         * @summary Fetching `ConfigSectionData`
         * @param {string} data ConfigSectionData identifier
         * @param {string} section ConfigSectionData identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configSectionDataControllerGet(data: string, section: string, options?: any): AxiosPromise<ConfigSectionDataGetResponseDTO> {
            return localVarFp.configSectionDataControllerGet(data, section, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for fetching list of `ConfigSectionDatas`
         * @summary Fetching list of `ConfigSectionDatas`
         * @param {number} limit ConfigSectionDataGetResponseDTO Items per page
         * @param {number} page ConfigSectionDataGetResponseDTO Page to return
         * @param {'createdAt' | 'key' | 'section' | 'updatedAt' | 'value'} orderBy ConfigSectionData order field
         * @param {'asc' | 'desc'} orderDirection ConfigSectionData order direction
         * @param {string} section ConfigSectionData identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configSectionDataControllerGetList(limit: number, page: number, orderBy: 'createdAt' | 'key' | 'section' | 'updatedAt' | 'value', orderDirection: 'asc' | 'desc', section: string, options?: any): AxiosPromise<ConfigSectionDataGetListResponseDTO> {
            return localVarFp.configSectionDataControllerGetList(limit, page, orderBy, orderDirection, section, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for partial updating `ConfigSectionData`
         * @summary Partial updating `ConfigSectionData`
         * @param {string} data ConfigSectionData identifier
         * @param {string} section ConfigSectionData identifier
         * @param {ConfigSectionDataPartialUpdateRequestBodyDTO} configSectionDataPartialUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configSectionDataControllerPartialUpdate(data: string, section: string, configSectionDataPartialUpdateRequestBodyDTO: ConfigSectionDataPartialUpdateRequestBodyDTO, options?: any): AxiosPromise<ConfigSectionDataPartialUpdateResponseDTO> {
            return localVarFp.configSectionDataControllerPartialUpdate(data, section, configSectionDataPartialUpdateRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for updating `ConfigSectionData`
         * @summary Updating `ConfigSectionData`
         * @param {string} data ConfigSectionData identifier
         * @param {string} section ConfigSectionData identifier
         * @param {ConfigSectionDataUpdateRequestBodyDTO} configSectionDataUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configSectionDataControllerUpdate(data: string, section: string, configSectionDataUpdateRequestBodyDTO: ConfigSectionDataUpdateRequestBodyDTO, options?: any): AxiosPromise<ConfigSectionDataUpdateResponseDTO> {
            return localVarFp.configSectionDataControllerUpdate(data, section, configSectionDataUpdateRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfigSectionDataApi - object-oriented interface
 * @export
 * @class ConfigSectionDataApi
 * @extends {BaseAPI}
 */
export class ConfigSectionDataApi extends BaseAPI {
    /**
     * This method is used for creating `ConfigSectionData`
     * @summary Creating `ConfigSectionData`
     * @param {string} section ConfigSectionData identifier
     * @param {ConfigSectionDataCreateRequestBodyDTO} configSectionDataCreateRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigSectionDataApi
     */
    public configSectionDataControllerCreate(section: string, configSectionDataCreateRequestBodyDTO: ConfigSectionDataCreateRequestBodyDTO, options?: AxiosRequestConfig) {
        return ConfigSectionDataApiFp(this.configuration).configSectionDataControllerCreate(section, configSectionDataCreateRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for deleting `ConfigSectionData`
     * @summary Deleting `ConfigSectionData`
     * @param {string} data ConfigSectionData identifier
     * @param {string} section ConfigSectionData identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigSectionDataApi
     */
    public configSectionDataControllerDelete(data: string, section: string, options?: AxiosRequestConfig) {
        return ConfigSectionDataApiFp(this.configuration).configSectionDataControllerDelete(data, section, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for fetching `ConfigSectionData`
     * @summary Fetching `ConfigSectionData`
     * @param {string} data ConfigSectionData identifier
     * @param {string} section ConfigSectionData identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigSectionDataApi
     */
    public configSectionDataControllerGet(data: string, section: string, options?: AxiosRequestConfig) {
        return ConfigSectionDataApiFp(this.configuration).configSectionDataControllerGet(data, section, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for fetching list of `ConfigSectionDatas`
     * @summary Fetching list of `ConfigSectionDatas`
     * @param {number} limit ConfigSectionDataGetResponseDTO Items per page
     * @param {number} page ConfigSectionDataGetResponseDTO Page to return
     * @param {'createdAt' | 'key' | 'section' | 'updatedAt' | 'value'} orderBy ConfigSectionData order field
     * @param {'asc' | 'desc'} orderDirection ConfigSectionData order direction
     * @param {string} section ConfigSectionData identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigSectionDataApi
     */
    public configSectionDataControllerGetList(limit: number, page: number, orderBy: 'createdAt' | 'key' | 'section' | 'updatedAt' | 'value', orderDirection: 'asc' | 'desc', section: string, options?: AxiosRequestConfig) {
        return ConfigSectionDataApiFp(this.configuration).configSectionDataControllerGetList(limit, page, orderBy, orderDirection, section, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for partial updating `ConfigSectionData`
     * @summary Partial updating `ConfigSectionData`
     * @param {string} data ConfigSectionData identifier
     * @param {string} section ConfigSectionData identifier
     * @param {ConfigSectionDataPartialUpdateRequestBodyDTO} configSectionDataPartialUpdateRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigSectionDataApi
     */
    public configSectionDataControllerPartialUpdate(data: string, section: string, configSectionDataPartialUpdateRequestBodyDTO: ConfigSectionDataPartialUpdateRequestBodyDTO, options?: AxiosRequestConfig) {
        return ConfigSectionDataApiFp(this.configuration).configSectionDataControllerPartialUpdate(data, section, configSectionDataPartialUpdateRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for updating `ConfigSectionData`
     * @summary Updating `ConfigSectionData`
     * @param {string} data ConfigSectionData identifier
     * @param {string} section ConfigSectionData identifier
     * @param {ConfigSectionDataUpdateRequestBodyDTO} configSectionDataUpdateRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigSectionDataApi
     */
    public configSectionDataControllerUpdate(data: string, section: string, configSectionDataUpdateRequestBodyDTO: ConfigSectionDataUpdateRequestBodyDTO, options?: AxiosRequestConfig) {
        return ConfigSectionDataApiFp(this.configuration).configSectionDataControllerUpdate(data, section, configSectionDataUpdateRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CurrencyApi - axios parameter creator
 * @export
 */
export const CurrencyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This method is used for creating `Currency`
         * @summary Creating `Currency`
         * @param {CurrencyCreateRequestBodyDTO} currencyCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyControllerCreate: async (currencyCreateRequestBodyDTO: CurrencyCreateRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currencyCreateRequestBodyDTO' is not null or undefined
            assertParamExists('currencyControllerCreate', 'currencyCreateRequestBodyDTO', currencyCreateRequestBodyDTO)
            const localVarPath = `/v1/currency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(currencyCreateRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for deleting `Currency`
         * @summary Deleting `Currency`
         * @param {string} currency Currency identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyControllerDelete: async (currency: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            assertParamExists('currencyControllerDelete', 'currency', currency)
            const localVarPath = `/v1/currency/{currency}`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for fetching `Currency`
         * @summary Fetching `Currency`
         * @param {string} currency Currency identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyControllerGet: async (currency: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            assertParamExists('currencyControllerGet', 'currency', currency)
            const localVarPath = `/v1/currency/{currency}`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for fetching list of `Currencys`
         * @summary Fetching list of `Currencys`
         * @param {number} limit CurrencyGetResponseDTO Items per page
         * @param {number} page CurrencyGetResponseDTO Page to return
         * @param {'code' | 'createdAt' | 'precision' | 'type' | 'updatedAt'} orderBy Currency order field
         * @param {'asc' | 'desc'} orderDirection Currency order direction
         * @param {number} [precision] Currency precision
         * @param {'crypto' | 'fiat'} [type] Currency type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyControllerGetList: async (limit: number, page: number, orderBy: 'code' | 'createdAt' | 'precision' | 'type' | 'updatedAt', orderDirection: 'asc' | 'desc', precision?: number, type?: 'crypto' | 'fiat', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('currencyControllerGetList', 'limit', limit)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('currencyControllerGetList', 'page', page)
            // verify required parameter 'orderBy' is not null or undefined
            assertParamExists('currencyControllerGetList', 'orderBy', orderBy)
            // verify required parameter 'orderDirection' is not null or undefined
            assertParamExists('currencyControllerGetList', 'orderDirection', orderDirection)
            const localVarPath = `/v1/currency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (precision !== undefined) {
                localVarQueryParameter['precision'] = precision;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for updating `Currency`
         * @summary Updating `Currency`
         * @param {string} currency Currency identifier
         * @param {CurrencyPartialUpdateRequestBodyDTO} currencyPartialUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyControllerPartialUpdate: async (currency: string, currencyPartialUpdateRequestBodyDTO: CurrencyPartialUpdateRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            assertParamExists('currencyControllerPartialUpdate', 'currency', currency)
            // verify required parameter 'currencyPartialUpdateRequestBodyDTO' is not null or undefined
            assertParamExists('currencyControllerPartialUpdate', 'currencyPartialUpdateRequestBodyDTO', currencyPartialUpdateRequestBodyDTO)
            const localVarPath = `/v1/currency/{currency}`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(currencyPartialUpdateRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for updating `Currency`
         * @summary Updating `Currency`
         * @param {string} currency Currency identifier
         * @param {CurrencyUpdateRequestBodyDTO} currencyUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyControllerUpdate: async (currency: string, currencyUpdateRequestBodyDTO: CurrencyUpdateRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            assertParamExists('currencyControllerUpdate', 'currency', currency)
            // verify required parameter 'currencyUpdateRequestBodyDTO' is not null or undefined
            assertParamExists('currencyControllerUpdate', 'currencyUpdateRequestBodyDTO', currencyUpdateRequestBodyDTO)
            const localVarPath = `/v1/currency/{currency}`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(currencyUpdateRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrencyApi - functional programming interface
 * @export
 */
export const CurrencyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CurrencyApiAxiosParamCreator(configuration)
    return {
        /**
         * This method is used for creating `Currency`
         * @summary Creating `Currency`
         * @param {CurrencyCreateRequestBodyDTO} currencyCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyControllerCreate(currencyCreateRequestBodyDTO: CurrencyCreateRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyCreateResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyControllerCreate(currencyCreateRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for deleting `Currency`
         * @summary Deleting `Currency`
         * @param {string} currency Currency identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyControllerDelete(currency: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyControllerDelete(currency, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for fetching `Currency`
         * @summary Fetching `Currency`
         * @param {string} currency Currency identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyControllerGet(currency: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyGetResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyControllerGet(currency, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for fetching list of `Currencys`
         * @summary Fetching list of `Currencys`
         * @param {number} limit CurrencyGetResponseDTO Items per page
         * @param {number} page CurrencyGetResponseDTO Page to return
         * @param {'code' | 'createdAt' | 'precision' | 'type' | 'updatedAt'} orderBy Currency order field
         * @param {'asc' | 'desc'} orderDirection Currency order direction
         * @param {number} [precision] Currency precision
         * @param {'crypto' | 'fiat'} [type] Currency type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyControllerGetList(limit: number, page: number, orderBy: 'code' | 'createdAt' | 'precision' | 'type' | 'updatedAt', orderDirection: 'asc' | 'desc', precision?: number, type?: 'crypto' | 'fiat', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyGetListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyControllerGetList(limit, page, orderBy, orderDirection, precision, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for updating `Currency`
         * @summary Updating `Currency`
         * @param {string} currency Currency identifier
         * @param {CurrencyPartialUpdateRequestBodyDTO} currencyPartialUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyControllerPartialUpdate(currency: string, currencyPartialUpdateRequestBodyDTO: CurrencyPartialUpdateRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyPartialUpdateResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyControllerPartialUpdate(currency, currencyPartialUpdateRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for updating `Currency`
         * @summary Updating `Currency`
         * @param {string} currency Currency identifier
         * @param {CurrencyUpdateRequestBodyDTO} currencyUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyControllerUpdate(currency: string, currencyUpdateRequestBodyDTO: CurrencyUpdateRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyUpdateResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyControllerUpdate(currency, currencyUpdateRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CurrencyApi - factory interface
 * @export
 */
export const CurrencyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CurrencyApiFp(configuration)
    return {
        /**
         * This method is used for creating `Currency`
         * @summary Creating `Currency`
         * @param {CurrencyCreateRequestBodyDTO} currencyCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyControllerCreate(currencyCreateRequestBodyDTO: CurrencyCreateRequestBodyDTO, options?: any): AxiosPromise<CurrencyCreateResponseDTO> {
            return localVarFp.currencyControllerCreate(currencyCreateRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for deleting `Currency`
         * @summary Deleting `Currency`
         * @param {string} currency Currency identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyControllerDelete(currency: string, options?: any): AxiosPromise<void> {
            return localVarFp.currencyControllerDelete(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for fetching `Currency`
         * @summary Fetching `Currency`
         * @param {string} currency Currency identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyControllerGet(currency: string, options?: any): AxiosPromise<CurrencyGetResponseDTO> {
            return localVarFp.currencyControllerGet(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for fetching list of `Currencys`
         * @summary Fetching list of `Currencys`
         * @param {number} limit CurrencyGetResponseDTO Items per page
         * @param {number} page CurrencyGetResponseDTO Page to return
         * @param {'code' | 'createdAt' | 'precision' | 'type' | 'updatedAt'} orderBy Currency order field
         * @param {'asc' | 'desc'} orderDirection Currency order direction
         * @param {number} [precision] Currency precision
         * @param {'crypto' | 'fiat'} [type] Currency type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyControllerGetList(limit: number, page: number, orderBy: 'code' | 'createdAt' | 'precision' | 'type' | 'updatedAt', orderDirection: 'asc' | 'desc', precision?: number, type?: 'crypto' | 'fiat', options?: any): AxiosPromise<CurrencyGetListResponseDTO> {
            return localVarFp.currencyControllerGetList(limit, page, orderBy, orderDirection, precision, type, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for updating `Currency`
         * @summary Updating `Currency`
         * @param {string} currency Currency identifier
         * @param {CurrencyPartialUpdateRequestBodyDTO} currencyPartialUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyControllerPartialUpdate(currency: string, currencyPartialUpdateRequestBodyDTO: CurrencyPartialUpdateRequestBodyDTO, options?: any): AxiosPromise<CurrencyPartialUpdateResponseDTO> {
            return localVarFp.currencyControllerPartialUpdate(currency, currencyPartialUpdateRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for updating `Currency`
         * @summary Updating `Currency`
         * @param {string} currency Currency identifier
         * @param {CurrencyUpdateRequestBodyDTO} currencyUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyControllerUpdate(currency: string, currencyUpdateRequestBodyDTO: CurrencyUpdateRequestBodyDTO, options?: any): AxiosPromise<CurrencyUpdateResponseDTO> {
            return localVarFp.currencyControllerUpdate(currency, currencyUpdateRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CurrencyApi - object-oriented interface
 * @export
 * @class CurrencyApi
 * @extends {BaseAPI}
 */
export class CurrencyApi extends BaseAPI {
    /**
     * This method is used for creating `Currency`
     * @summary Creating `Currency`
     * @param {CurrencyCreateRequestBodyDTO} currencyCreateRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyControllerCreate(currencyCreateRequestBodyDTO: CurrencyCreateRequestBodyDTO, options?: AxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyControllerCreate(currencyCreateRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for deleting `Currency`
     * @summary Deleting `Currency`
     * @param {string} currency Currency identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyControllerDelete(currency: string, options?: AxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyControllerDelete(currency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for fetching `Currency`
     * @summary Fetching `Currency`
     * @param {string} currency Currency identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyControllerGet(currency: string, options?: AxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyControllerGet(currency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for fetching list of `Currencys`
     * @summary Fetching list of `Currencys`
     * @param {number} limit CurrencyGetResponseDTO Items per page
     * @param {number} page CurrencyGetResponseDTO Page to return
     * @param {'code' | 'createdAt' | 'precision' | 'type' | 'updatedAt'} orderBy Currency order field
     * @param {'asc' | 'desc'} orderDirection Currency order direction
     * @param {number} [precision] Currency precision
     * @param {'crypto' | 'fiat'} [type] Currency type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyControllerGetList(limit: number, page: number, orderBy: 'code' | 'createdAt' | 'precision' | 'type' | 'updatedAt', orderDirection: 'asc' | 'desc', precision?: number, type?: 'crypto' | 'fiat', options?: AxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyControllerGetList(limit, page, orderBy, orderDirection, precision, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for updating `Currency`
     * @summary Updating `Currency`
     * @param {string} currency Currency identifier
     * @param {CurrencyPartialUpdateRequestBodyDTO} currencyPartialUpdateRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyControllerPartialUpdate(currency: string, currencyPartialUpdateRequestBodyDTO: CurrencyPartialUpdateRequestBodyDTO, options?: AxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyControllerPartialUpdate(currency, currencyPartialUpdateRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for updating `Currency`
     * @summary Updating `Currency`
     * @param {string} currency Currency identifier
     * @param {CurrencyUpdateRequestBodyDTO} currencyUpdateRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyControllerUpdate(currency: string, currencyUpdateRequestBodyDTO: CurrencyUpdateRequestBodyDTO, options?: AxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyControllerUpdate(currency, currencyUpdateRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DepositApi - axios parameter creator
 * @export
 */
export const DepositApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This method is used for creating `Deposit`
         * @summary Creating `Deposit`
         * @param {DepositCreateRequestBodyDTO} depositCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        depositControllerCreate: async (depositCreateRequestBodyDTO: DepositCreateRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'depositCreateRequestBodyDTO' is not null or undefined
            assertParamExists('depositControllerCreate', 'depositCreateRequestBodyDTO', depositCreateRequestBodyDTO)
            const localVarPath = `/v1/deposit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(depositCreateRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for fetching `Deposit`
         * @summary Fetching `Deposit`
         * @param {string} deposit Deposit identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        depositControllerGet: async (deposit: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deposit' is not null or undefined
            assertParamExists('depositControllerGet', 'deposit', deposit)
            const localVarPath = `/v1/deposit/{deposit}`
                .replace(`{${"deposit"}}`, encodeURIComponent(String(deposit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for fetching list of `Deposits`
         * @summary Fetching list of `Deposits`
         * @param {number} limit DepositGetResponseDTO Items per page
         * @param {number} page DepositGetResponseDTO Page to return
         * @param {'amount' | 'createdAt' | 'customerID' | 'description' | 'internalID' | 'ip' | 'status' | 'type' | 'updatedAt'} orderBy Deposit order field
         * @param {'asc' | 'desc'} orderDirection Deposit order direction
         * @param {string} [account] Account identifier
         * @param {number} [amountFrom] Deposit amount from
         * @param {number} [amountTo] Deposit amount to
         * @param {string} [currency] Currency identifier
         * @param {string} [customerID] Deposit customer identifier
         * @param {string} [dateFrom] Deposit from date
         * @param {string} [dateTo] Deposit to date
         * @param {string} [internalID] Deposit internal identifier
         * @param {Set<'canceled' | 'expired' | 'paid' | 'waiting'>} [status] Array of Deposit status
         * @param {string} [type] Type identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        depositControllerGetList: async (limit: number, page: number, orderBy: 'amount' | 'createdAt' | 'customerID' | 'description' | 'internalID' | 'ip' | 'status' | 'type' | 'updatedAt', orderDirection: 'asc' | 'desc', account?: string, amountFrom?: number, amountTo?: number, currency?: string, customerID?: string, dateFrom?: string, dateTo?: string, internalID?: string, status?: Set<'canceled' | 'expired' | 'paid' | 'waiting'>, type?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('depositControllerGetList', 'limit', limit)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('depositControllerGetList', 'page', page)
            // verify required parameter 'orderBy' is not null or undefined
            assertParamExists('depositControllerGetList', 'orderBy', orderBy)
            // verify required parameter 'orderDirection' is not null or undefined
            assertParamExists('depositControllerGetList', 'orderDirection', orderDirection)
            const localVarPath = `/v1/deposit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (amountFrom !== undefined) {
                localVarQueryParameter['amountFrom'] = amountFrom;
            }

            if (amountTo !== undefined) {
                localVarQueryParameter['amountTo'] = amountTo;
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }

            if (customerID !== undefined) {
                localVarQueryParameter['customerID'] = customerID;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString() :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString() :
                    dateTo;
            }

            if (internalID !== undefined) {
                localVarQueryParameter['internalID'] = internalID;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (status) {
                localVarQueryParameter['status'] = Array.from(status);
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DepositApi - functional programming interface
 * @export
 */
export const DepositApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DepositApiAxiosParamCreator(configuration)
    return {
        /**
         * This method is used for creating `Deposit`
         * @summary Creating `Deposit`
         * @param {DepositCreateRequestBodyDTO} depositCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async depositControllerCreate(depositCreateRequestBodyDTO: DepositCreateRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositCreateResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.depositControllerCreate(depositCreateRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for fetching `Deposit`
         * @summary Fetching `Deposit`
         * @param {string} deposit Deposit identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async depositControllerGet(deposit: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositGetResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.depositControllerGet(deposit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for fetching list of `Deposits`
         * @summary Fetching list of `Deposits`
         * @param {number} limit DepositGetResponseDTO Items per page
         * @param {number} page DepositGetResponseDTO Page to return
         * @param {'amount' | 'createdAt' | 'customerID' | 'description' | 'internalID' | 'ip' | 'status' | 'type' | 'updatedAt'} orderBy Deposit order field
         * @param {'asc' | 'desc'} orderDirection Deposit order direction
         * @param {string} [account] Account identifier
         * @param {number} [amountFrom] Deposit amount from
         * @param {number} [amountTo] Deposit amount to
         * @param {string} [currency] Currency identifier
         * @param {string} [customerID] Deposit customer identifier
         * @param {string} [dateFrom] Deposit from date
         * @param {string} [dateTo] Deposit to date
         * @param {string} [internalID] Deposit internal identifier
         * @param {Set<'canceled' | 'expired' | 'paid' | 'waiting'>} [status] Array of Deposit status
         * @param {string} [type] Type identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async depositControllerGetList(limit: number, page: number, orderBy: 'amount' | 'createdAt' | 'customerID' | 'description' | 'internalID' | 'ip' | 'status' | 'type' | 'updatedAt', orderDirection: 'asc' | 'desc', account?: string, amountFrom?: number, amountTo?: number, currency?: string, customerID?: string, dateFrom?: string, dateTo?: string, internalID?: string, status?: Set<'canceled' | 'expired' | 'paid' | 'waiting'>, type?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositGetListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.depositControllerGetList(limit, page, orderBy, orderDirection, account, amountFrom, amountTo, currency, customerID, dateFrom, dateTo, internalID, status, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DepositApi - factory interface
 * @export
 */
export const DepositApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DepositApiFp(configuration)
    return {
        /**
         * This method is used for creating `Deposit`
         * @summary Creating `Deposit`
         * @param {DepositCreateRequestBodyDTO} depositCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        depositControllerCreate(depositCreateRequestBodyDTO: DepositCreateRequestBodyDTO, options?: any): AxiosPromise<DepositCreateResponseDTO> {
            return localVarFp.depositControllerCreate(depositCreateRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for fetching `Deposit`
         * @summary Fetching `Deposit`
         * @param {string} deposit Deposit identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        depositControllerGet(deposit: string, options?: any): AxiosPromise<DepositGetResponseDTO> {
            return localVarFp.depositControllerGet(deposit, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for fetching list of `Deposits`
         * @summary Fetching list of `Deposits`
         * @param {number} limit DepositGetResponseDTO Items per page
         * @param {number} page DepositGetResponseDTO Page to return
         * @param {'amount' | 'createdAt' | 'customerID' | 'description' | 'internalID' | 'ip' | 'status' | 'type' | 'updatedAt'} orderBy Deposit order field
         * @param {'asc' | 'desc'} orderDirection Deposit order direction
         * @param {string} [account] Account identifier
         * @param {number} [amountFrom] Deposit amount from
         * @param {number} [amountTo] Deposit amount to
         * @param {string} [currency] Currency identifier
         * @param {string} [customerID] Deposit customer identifier
         * @param {string} [dateFrom] Deposit from date
         * @param {string} [dateTo] Deposit to date
         * @param {string} [internalID] Deposit internal identifier
         * @param {Set<'canceled' | 'expired' | 'paid' | 'waiting'>} [status] Array of Deposit status
         * @param {string} [type] Type identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        depositControllerGetList(limit: number, page: number, orderBy: 'amount' | 'createdAt' | 'customerID' | 'description' | 'internalID' | 'ip' | 'status' | 'type' | 'updatedAt', orderDirection: 'asc' | 'desc', account?: string, amountFrom?: number, amountTo?: number, currency?: string, customerID?: string, dateFrom?: string, dateTo?: string, internalID?: string, status?: Set<'canceled' | 'expired' | 'paid' | 'waiting'>, type?: string, options?: any): AxiosPromise<DepositGetListResponseDTO> {
            return localVarFp.depositControllerGetList(limit, page, orderBy, orderDirection, account, amountFrom, amountTo, currency, customerID, dateFrom, dateTo, internalID, status, type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DepositApi - object-oriented interface
 * @export
 * @class DepositApi
 * @extends {BaseAPI}
 */
export class DepositApi extends BaseAPI {
    /**
     * This method is used for creating `Deposit`
     * @summary Creating `Deposit`
     * @param {DepositCreateRequestBodyDTO} depositCreateRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepositApi
     */
    public depositControllerCreate(depositCreateRequestBodyDTO: DepositCreateRequestBodyDTO, options?: AxiosRequestConfig) {
        return DepositApiFp(this.configuration).depositControllerCreate(depositCreateRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for fetching `Deposit`
     * @summary Fetching `Deposit`
     * @param {string} deposit Deposit identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepositApi
     */
    public depositControllerGet(deposit: string, options?: AxiosRequestConfig) {
        return DepositApiFp(this.configuration).depositControllerGet(deposit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for fetching list of `Deposits`
     * @summary Fetching list of `Deposits`
     * @param {number} limit DepositGetResponseDTO Items per page
     * @param {number} page DepositGetResponseDTO Page to return
     * @param {'amount' | 'createdAt' | 'customerID' | 'description' | 'internalID' | 'ip' | 'status' | 'type' | 'updatedAt'} orderBy Deposit order field
     * @param {'asc' | 'desc'} orderDirection Deposit order direction
     * @param {string} [account] Account identifier
     * @param {number} [amountFrom] Deposit amount from
     * @param {number} [amountTo] Deposit amount to
     * @param {string} [currency] Currency identifier
     * @param {string} [customerID] Deposit customer identifier
     * @param {string} [dateFrom] Deposit from date
     * @param {string} [dateTo] Deposit to date
     * @param {string} [internalID] Deposit internal identifier
     * @param {Set<'canceled' | 'expired' | 'paid' | 'waiting'>} [status] Array of Deposit status
     * @param {string} [type] Type identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepositApi
     */
    public depositControllerGetList(limit: number, page: number, orderBy: 'amount' | 'createdAt' | 'customerID' | 'description' | 'internalID' | 'ip' | 'status' | 'type' | 'updatedAt', orderDirection: 'asc' | 'desc', account?: string, amountFrom?: number, amountTo?: number, currency?: string, customerID?: string, dateFrom?: string, dateTo?: string, internalID?: string, status?: Set<'canceled' | 'expired' | 'paid' | 'waiting'>, type?: string, options?: AxiosRequestConfig) {
        return DepositApiFp(this.configuration).depositControllerGetList(limit, page, orderBy, orderDirection, account, amountFrom, amountTo, currency, customerID, dateFrom, dateTo, internalID, status, type, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InfoApi - axios parameter creator
 * @export
 */
export const InfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This method is used for fetching `Health`
         * @summary Fetching `Health`
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoHealthControllerCheck: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/info/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoApi - functional programming interface
 * @export
 */
export const InfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfoApiAxiosParamCreator(configuration)
    return {
        /**
         * This method is used for fetching `Health`
         * @summary Fetching `Health`
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infoHealthControllerCheck(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InfoHealthGettingResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.infoHealthControllerCheck(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InfoApi - factory interface
 * @export
 */
export const InfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfoApiFp(configuration)
    return {
        /**
         * This method is used for fetching `Health`
         * @summary Fetching `Health`
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoHealthControllerCheck(options?: any): AxiosPromise<InfoHealthGettingResponseDTO> {
            return localVarFp.infoHealthControllerCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfoApi - object-oriented interface
 * @export
 * @class InfoApi
 * @extends {BaseAPI}
 */
export class InfoApi extends BaseAPI {
    /**
     * This method is used for fetching `Health`
     * @summary Fetching `Health`
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public infoHealthControllerCheck(options?: AxiosRequestConfig) {
        return InfoApiFp(this.configuration).infoHealthControllerCheck(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MessageApi - axios parameter creator
 * @export
 */
export const MessageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This method is used for creating `Message`
         * @summary Creating `Message`
         * @param {MessageCreateRequestBodyDTO} messageCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageControllerCreate: async (messageCreateRequestBodyDTO: MessageCreateRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageCreateRequestBodyDTO' is not null or undefined
            assertParamExists('messageControllerCreate', 'messageCreateRequestBodyDTO', messageCreateRequestBodyDTO)
            const localVarPath = `/v1/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accountAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication accountRequestSignature required
            await setApiKeyToObject(localVarHeaderParameter, "X-Signature", configuration)

            // authentication accountRequestTimestamp required
            await setApiKeyToObject(localVarHeaderParameter, "X-Timestamp", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messageCreateRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessageApi - functional programming interface
 * @export
 */
export const MessageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessageApiAxiosParamCreator(configuration)
    return {
        /**
         * This method is used for creating `Message`
         * @summary Creating `Message`
         * @param {MessageCreateRequestBodyDTO} messageCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messageControllerCreate(messageCreateRequestBodyDTO: MessageCreateRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyCreateResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messageControllerCreate(messageCreateRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MessageApi - factory interface
 * @export
 */
export const MessageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessageApiFp(configuration)
    return {
        /**
         * This method is used for creating `Message`
         * @summary Creating `Message`
         * @param {MessageCreateRequestBodyDTO} messageCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageControllerCreate(messageCreateRequestBodyDTO: MessageCreateRequestBodyDTO, options?: any): AxiosPromise<CurrencyCreateResponseDTO> {
            return localVarFp.messageControllerCreate(messageCreateRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessageApi - object-oriented interface
 * @export
 * @class MessageApi
 * @extends {BaseAPI}
 */
export class MessageApi extends BaseAPI {
    /**
     * This method is used for creating `Message`
     * @summary Creating `Message`
     * @param {MessageCreateRequestBodyDTO} messageCreateRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public messageControllerCreate(messageCreateRequestBodyDTO: MessageCreateRequestBodyDTO, options?: AxiosRequestConfig) {
        return MessageApiFp(this.configuration).messageControllerCreate(messageCreateRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StatisticsApi - axios parameter creator
 * @export
 */
export const StatisticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This method is used for fetching simple list of `Statisticss`
         * @summary Fetching simple list of `Statisticss`
         * @param {number} limit StatisticsGetSimpleListResponseDTO Items per page
         * @param {number} page StatisticsGetSimpleListResponseDTO Page to return
         * @param {'day' | 'hour' | 'month' | 'week' | 'year'} groupBy Statistics group by
         * @param {'amount' | 'conversion' | 'date' | 'successfullCount' | 'totalCount'} orderBy Statistics order field
         * @param {'asc' | 'desc'} orderDirection Statistics order direction
         * @param {'deposit' | 'transfer'} type Statistics type
         * @param {string} [dateFrom] Statistics from date
         * @param {string} [dateTo] Statistics to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsControllerGetSimpleList: async (limit: number, page: number, groupBy: 'day' | 'hour' | 'month' | 'week' | 'year', orderBy: 'amount' | 'conversion' | 'date' | 'successfullCount' | 'totalCount', orderDirection: 'asc' | 'desc', type: 'deposit' | 'transfer', dateFrom?: string, dateTo?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('statisticsControllerGetSimpleList', 'limit', limit)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('statisticsControllerGetSimpleList', 'page', page)
            // verify required parameter 'groupBy' is not null or undefined
            assertParamExists('statisticsControllerGetSimpleList', 'groupBy', groupBy)
            // verify required parameter 'orderBy' is not null or undefined
            assertParamExists('statisticsControllerGetSimpleList', 'orderBy', orderBy)
            // verify required parameter 'orderDirection' is not null or undefined
            assertParamExists('statisticsControllerGetSimpleList', 'orderDirection', orderDirection)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('statisticsControllerGetSimpleList', 'type', type)
            const localVarPath = `/v1/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accountAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication accountRequestSignature required
            await setApiKeyToObject(localVarHeaderParameter, "X-Signature", configuration)

            // authentication accountRequestTimestamp required
            await setApiKeyToObject(localVarHeaderParameter, "X-Timestamp", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString() :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString() :
                    dateTo;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatisticsApi - functional programming interface
 * @export
 */
export const StatisticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatisticsApiAxiosParamCreator(configuration)
    return {
        /**
         * This method is used for fetching simple list of `Statisticss`
         * @summary Fetching simple list of `Statisticss`
         * @param {number} limit StatisticsGetSimpleListResponseDTO Items per page
         * @param {number} page StatisticsGetSimpleListResponseDTO Page to return
         * @param {'day' | 'hour' | 'month' | 'week' | 'year'} groupBy Statistics group by
         * @param {'amount' | 'conversion' | 'date' | 'successfullCount' | 'totalCount'} orderBy Statistics order field
         * @param {'asc' | 'desc'} orderDirection Statistics order direction
         * @param {'deposit' | 'transfer'} type Statistics type
         * @param {string} [dateFrom] Statistics from date
         * @param {string} [dateTo] Statistics to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statisticsControllerGetSimpleList(limit: number, page: number, groupBy: 'day' | 'hour' | 'month' | 'week' | 'year', orderBy: 'amount' | 'conversion' | 'date' | 'successfullCount' | 'totalCount', orderDirection: 'asc' | 'desc', type: 'deposit' | 'transfer', dateFrom?: string, dateTo?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatisticsGetSimpleListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statisticsControllerGetSimpleList(limit, page, groupBy, orderBy, orderDirection, type, dateFrom, dateTo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatisticsApi - factory interface
 * @export
 */
export const StatisticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatisticsApiFp(configuration)
    return {
        /**
         * This method is used for fetching simple list of `Statisticss`
         * @summary Fetching simple list of `Statisticss`
         * @param {number} limit StatisticsGetSimpleListResponseDTO Items per page
         * @param {number} page StatisticsGetSimpleListResponseDTO Page to return
         * @param {'day' | 'hour' | 'month' | 'week' | 'year'} groupBy Statistics group by
         * @param {'amount' | 'conversion' | 'date' | 'successfullCount' | 'totalCount'} orderBy Statistics order field
         * @param {'asc' | 'desc'} orderDirection Statistics order direction
         * @param {'deposit' | 'transfer'} type Statistics type
         * @param {string} [dateFrom] Statistics from date
         * @param {string} [dateTo] Statistics to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsControllerGetSimpleList(limit: number, page: number, groupBy: 'day' | 'hour' | 'month' | 'week' | 'year', orderBy: 'amount' | 'conversion' | 'date' | 'successfullCount' | 'totalCount', orderDirection: 'asc' | 'desc', type: 'deposit' | 'transfer', dateFrom?: string, dateTo?: string, options?: any): AxiosPromise<StatisticsGetSimpleListResponseDTO> {
            return localVarFp.statisticsControllerGetSimpleList(limit, page, groupBy, orderBy, orderDirection, type, dateFrom, dateTo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatisticsApi - object-oriented interface
 * @export
 * @class StatisticsApi
 * @extends {BaseAPI}
 */
export class StatisticsApi extends BaseAPI {
    /**
     * This method is used for fetching simple list of `Statisticss`
     * @summary Fetching simple list of `Statisticss`
     * @param {number} limit StatisticsGetSimpleListResponseDTO Items per page
     * @param {number} page StatisticsGetSimpleListResponseDTO Page to return
     * @param {'day' | 'hour' | 'month' | 'week' | 'year'} groupBy Statistics group by
     * @param {'amount' | 'conversion' | 'date' | 'successfullCount' | 'totalCount'} orderBy Statistics order field
     * @param {'asc' | 'desc'} orderDirection Statistics order direction
     * @param {'deposit' | 'transfer'} type Statistics type
     * @param {string} [dateFrom] Statistics from date
     * @param {string} [dateTo] Statistics to date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticsApi
     */
    public statisticsControllerGetSimpleList(limit: number, page: number, groupBy: 'day' | 'hour' | 'month' | 'week' | 'year', orderBy: 'amount' | 'conversion' | 'date' | 'successfullCount' | 'totalCount', orderDirection: 'asc' | 'desc', type: 'deposit' | 'transfer', dateFrom?: string, dateTo?: string, options?: AxiosRequestConfig) {
        return StatisticsApiFp(this.configuration).statisticsControllerGetSimpleList(limit, page, groupBy, orderBy, orderDirection, type, dateFrom, dateTo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TypeApi - axios parameter creator
 * @export
 */
export const TypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This method is used for creating `Type`
         * @summary Creating `Type`
         * @param {TypeCreateRequestBodyDTO} typeCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeControllerCreate: async (typeCreateRequestBodyDTO: TypeCreateRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typeCreateRequestBodyDTO' is not null or undefined
            assertParamExists('typeControllerCreate', 'typeCreateRequestBodyDTO', typeCreateRequestBodyDTO)
            const localVarPath = `/v1/type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typeCreateRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for deleting `Type`
         * @summary Deleting `Type`
         * @param {string} type Type identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeControllerDelete: async (type: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('typeControllerDelete', 'type', type)
            const localVarPath = `/v1/type/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for fetching `Type`
         * @summary Fetching `Type`
         * @param {string} type Type identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeControllerGet: async (type: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('typeControllerGet', 'type', type)
            const localVarPath = `/v1/type/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for fetching list of `Types`
         * @summary Fetching list of `Types`
         * @param {number} limit TypeGetResponseDTO Items per page
         * @param {number} page TypeGetResponseDTO Page to return
         * @param {'createdAt' | 'purseType' | 'updatedAt'} orderBy Type order field
         * @param {'asc' | 'desc'} orderDirection Type order direction
         * @param {'card' | 'wallet'} purseType Type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeControllerGetList: async (limit: number, page: number, orderBy: 'createdAt' | 'purseType' | 'updatedAt', orderDirection: 'asc' | 'desc', purseType: 'card' | 'wallet', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('typeControllerGetList', 'limit', limit)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('typeControllerGetList', 'page', page)
            // verify required parameter 'orderBy' is not null or undefined
            assertParamExists('typeControllerGetList', 'orderBy', orderBy)
            // verify required parameter 'orderDirection' is not null or undefined
            assertParamExists('typeControllerGetList', 'orderDirection', orderDirection)
            // verify required parameter 'purseType' is not null or undefined
            assertParamExists('typeControllerGetList', 'purseType', purseType)
            const localVarPath = `/v1/type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (purseType !== undefined) {
                localVarQueryParameter['purseType'] = purseType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for updating `Type`
         * @summary Updating `Type`
         * @param {string} type Type identifier
         * @param {TypePartialUpdateRequestBodyDTO} typePartialUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeControllerPartialUpdate: async (type: string, typePartialUpdateRequestBodyDTO: TypePartialUpdateRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('typeControllerPartialUpdate', 'type', type)
            // verify required parameter 'typePartialUpdateRequestBodyDTO' is not null or undefined
            assertParamExists('typeControllerPartialUpdate', 'typePartialUpdateRequestBodyDTO', typePartialUpdateRequestBodyDTO)
            const localVarPath = `/v1/type/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typePartialUpdateRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for updating `Type`
         * @summary Updating `Type`
         * @param {string} type Type identifier
         * @param {TypeUpdateRequestBodyDTO} typeUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeControllerUpdate: async (type: string, typeUpdateRequestBodyDTO: TypeUpdateRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('typeControllerUpdate', 'type', type)
            // verify required parameter 'typeUpdateRequestBodyDTO' is not null or undefined
            assertParamExists('typeControllerUpdate', 'typeUpdateRequestBodyDTO', typeUpdateRequestBodyDTO)
            const localVarPath = `/v1/type/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typeUpdateRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TypeApi - functional programming interface
 * @export
 */
export const TypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TypeApiAxiosParamCreator(configuration)
    return {
        /**
         * This method is used for creating `Type`
         * @summary Creating `Type`
         * @param {TypeCreateRequestBodyDTO} typeCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeControllerCreate(typeCreateRequestBodyDTO: TypeCreateRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypeCreateResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.typeControllerCreate(typeCreateRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for deleting `Type`
         * @summary Deleting `Type`
         * @param {string} type Type identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeControllerDelete(type: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.typeControllerDelete(type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for fetching `Type`
         * @summary Fetching `Type`
         * @param {string} type Type identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeControllerGet(type: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypeGetResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.typeControllerGet(type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for fetching list of `Types`
         * @summary Fetching list of `Types`
         * @param {number} limit TypeGetResponseDTO Items per page
         * @param {number} page TypeGetResponseDTO Page to return
         * @param {'createdAt' | 'purseType' | 'updatedAt'} orderBy Type order field
         * @param {'asc' | 'desc'} orderDirection Type order direction
         * @param {'card' | 'wallet'} purseType Type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeControllerGetList(limit: number, page: number, orderBy: 'createdAt' | 'purseType' | 'updatedAt', orderDirection: 'asc' | 'desc', purseType: 'card' | 'wallet', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypeGetListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.typeControllerGetList(limit, page, orderBy, orderDirection, purseType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for updating `Type`
         * @summary Updating `Type`
         * @param {string} type Type identifier
         * @param {TypePartialUpdateRequestBodyDTO} typePartialUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeControllerPartialUpdate(type: string, typePartialUpdateRequestBodyDTO: TypePartialUpdateRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypePartialUpdateResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.typeControllerPartialUpdate(type, typePartialUpdateRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for updating `Type`
         * @summary Updating `Type`
         * @param {string} type Type identifier
         * @param {TypeUpdateRequestBodyDTO} typeUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeControllerUpdate(type: string, typeUpdateRequestBodyDTO: TypeUpdateRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypeUpdateResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.typeControllerUpdate(type, typeUpdateRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TypeApi - factory interface
 * @export
 */
export const TypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TypeApiFp(configuration)
    return {
        /**
         * This method is used for creating `Type`
         * @summary Creating `Type`
         * @param {TypeCreateRequestBodyDTO} typeCreateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeControllerCreate(typeCreateRequestBodyDTO: TypeCreateRequestBodyDTO, options?: any): AxiosPromise<TypeCreateResponseDTO> {
            return localVarFp.typeControllerCreate(typeCreateRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for deleting `Type`
         * @summary Deleting `Type`
         * @param {string} type Type identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeControllerDelete(type: string, options?: any): AxiosPromise<void> {
            return localVarFp.typeControllerDelete(type, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for fetching `Type`
         * @summary Fetching `Type`
         * @param {string} type Type identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeControllerGet(type: string, options?: any): AxiosPromise<TypeGetResponseDTO> {
            return localVarFp.typeControllerGet(type, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for fetching list of `Types`
         * @summary Fetching list of `Types`
         * @param {number} limit TypeGetResponseDTO Items per page
         * @param {number} page TypeGetResponseDTO Page to return
         * @param {'createdAt' | 'purseType' | 'updatedAt'} orderBy Type order field
         * @param {'asc' | 'desc'} orderDirection Type order direction
         * @param {'card' | 'wallet'} purseType Type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeControllerGetList(limit: number, page: number, orderBy: 'createdAt' | 'purseType' | 'updatedAt', orderDirection: 'asc' | 'desc', purseType: 'card' | 'wallet', options?: any): AxiosPromise<TypeGetListResponseDTO> {
            return localVarFp.typeControllerGetList(limit, page, orderBy, orderDirection, purseType, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for updating `Type`
         * @summary Updating `Type`
         * @param {string} type Type identifier
         * @param {TypePartialUpdateRequestBodyDTO} typePartialUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeControllerPartialUpdate(type: string, typePartialUpdateRequestBodyDTO: TypePartialUpdateRequestBodyDTO, options?: any): AxiosPromise<TypePartialUpdateResponseDTO> {
            return localVarFp.typeControllerPartialUpdate(type, typePartialUpdateRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for updating `Type`
         * @summary Updating `Type`
         * @param {string} type Type identifier
         * @param {TypeUpdateRequestBodyDTO} typeUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeControllerUpdate(type: string, typeUpdateRequestBodyDTO: TypeUpdateRequestBodyDTO, options?: any): AxiosPromise<TypeUpdateResponseDTO> {
            return localVarFp.typeControllerUpdate(type, typeUpdateRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TypeApi - object-oriented interface
 * @export
 * @class TypeApi
 * @extends {BaseAPI}
 */
export class TypeApi extends BaseAPI {
    /**
     * This method is used for creating `Type`
     * @summary Creating `Type`
     * @param {TypeCreateRequestBodyDTO} typeCreateRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TypeApi
     */
    public typeControllerCreate(typeCreateRequestBodyDTO: TypeCreateRequestBodyDTO, options?: AxiosRequestConfig) {
        return TypeApiFp(this.configuration).typeControllerCreate(typeCreateRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for deleting `Type`
     * @summary Deleting `Type`
     * @param {string} type Type identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TypeApi
     */
    public typeControllerDelete(type: string, options?: AxiosRequestConfig) {
        return TypeApiFp(this.configuration).typeControllerDelete(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for fetching `Type`
     * @summary Fetching `Type`
     * @param {string} type Type identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TypeApi
     */
    public typeControllerGet(type: string, options?: AxiosRequestConfig) {
        return TypeApiFp(this.configuration).typeControllerGet(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for fetching list of `Types`
     * @summary Fetching list of `Types`
     * @param {number} limit TypeGetResponseDTO Items per page
     * @param {number} page TypeGetResponseDTO Page to return
     * @param {'createdAt' | 'purseType' | 'updatedAt'} orderBy Type order field
     * @param {'asc' | 'desc'} orderDirection Type order direction
     * @param {'card' | 'wallet'} purseType Type type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TypeApi
     */
    public typeControllerGetList(limit: number, page: number, orderBy: 'createdAt' | 'purseType' | 'updatedAt', orderDirection: 'asc' | 'desc', purseType: 'card' | 'wallet', options?: AxiosRequestConfig) {
        return TypeApiFp(this.configuration).typeControllerGetList(limit, page, orderBy, orderDirection, purseType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for updating `Type`
     * @summary Updating `Type`
     * @param {string} type Type identifier
     * @param {TypePartialUpdateRequestBodyDTO} typePartialUpdateRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TypeApi
     */
    public typeControllerPartialUpdate(type: string, typePartialUpdateRequestBodyDTO: TypePartialUpdateRequestBodyDTO, options?: AxiosRequestConfig) {
        return TypeApiFp(this.configuration).typeControllerPartialUpdate(type, typePartialUpdateRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for updating `Type`
     * @summary Updating `Type`
     * @param {string} type Type identifier
     * @param {TypeUpdateRequestBodyDTO} typeUpdateRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TypeApi
     */
    public typeControllerUpdate(type: string, typeUpdateRequestBodyDTO: TypeUpdateRequestBodyDTO, options?: AxiosRequestConfig) {
        return TypeApiFp(this.configuration).typeControllerUpdate(type, typeUpdateRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This method is used for fetching `User`
         * @summary Fetching `User`
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for partial updating `User`
         * @summary Partial updating `User`
         * @param {UserPartialUpdateRequestBodyDTO} userPartialUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerPartialUpdate: async (userPartialUpdateRequestBodyDTO: UserPartialUpdateRequestBodyDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userPartialUpdateRequestBodyDTO' is not null or undefined
            assertParamExists('userControllerPartialUpdate', 'userPartialUpdateRequestBodyDTO', userPartialUpdateRequestBodyDTO)
            const localVarPath = `/v1/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPartialUpdateRequestBodyDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * This method is used for fetching `User`
         * @summary Fetching `User`
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGetResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for partial updating `User`
         * @summary Partial updating `User`
         * @param {UserPartialUpdateRequestBodyDTO} userPartialUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerPartialUpdate(userPartialUpdateRequestBodyDTO: UserPartialUpdateRequestBodyDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPartialUpdateResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerPartialUpdate(userPartialUpdateRequestBodyDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * This method is used for fetching `User`
         * @summary Fetching `User`
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGet(options?: any): AxiosPromise<UserGetResponseDTO> {
            return localVarFp.userControllerGet(options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for partial updating `User`
         * @summary Partial updating `User`
         * @param {UserPartialUpdateRequestBodyDTO} userPartialUpdateRequestBodyDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerPartialUpdate(userPartialUpdateRequestBodyDTO: UserPartialUpdateRequestBodyDTO, options?: any): AxiosPromise<UserPartialUpdateResponseDTO> {
            return localVarFp.userControllerPartialUpdate(userPartialUpdateRequestBodyDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * This method is used for fetching `User`
     * @summary Fetching `User`
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerGet(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for partial updating `User`
     * @summary Partial updating `User`
     * @param {UserPartialUpdateRequestBodyDTO} userPartialUpdateRequestBodyDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerPartialUpdate(userPartialUpdateRequestBodyDTO: UserPartialUpdateRequestBodyDTO, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerPartialUpdate(userPartialUpdateRequestBodyDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserBalanceApi - axios parameter creator
 * @export
 */
export const UserBalanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This method is used for fetching `UserBalance`
         * @summary Fetching `UserBalance`
         * @param {string} balance UserBalance identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBalanceControllerGet: async (balance: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'balance' is not null or undefined
            assertParamExists('userBalanceControllerGet', 'balance', balance)
            const localVarPath = `/v1/user/balance/{balance}`
                .replace(`{${"balance"}}`, encodeURIComponent(String(balance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for fetching list of `UserBalances`
         * @summary Fetching list of `UserBalances`
         * @param {number} limit UserBalanceGetResponseDTO Items per page
         * @param {number} page UserBalanceGetResponseDTO Page to return
         * @param {'balance' | 'createdAt' | 'updatedAt'} orderBy UserBalance order field
         * @param {'asc' | 'desc'} orderDirection UserBalance order direction
         * @param {'crypto' | 'fiat'} [type] UserBalance currency type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBalanceControllerGetList: async (limit: number, page: number, orderBy: 'balance' | 'createdAt' | 'updatedAt', orderDirection: 'asc' | 'desc', type?: 'crypto' | 'fiat', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('userBalanceControllerGetList', 'limit', limit)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('userBalanceControllerGetList', 'page', page)
            // verify required parameter 'orderBy' is not null or undefined
            assertParamExists('userBalanceControllerGetList', 'orderBy', orderBy)
            // verify required parameter 'orderDirection' is not null or undefined
            assertParamExists('userBalanceControllerGetList', 'orderDirection', orderDirection)
            const localVarPath = `/v1/user/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserBalanceApi - functional programming interface
 * @export
 */
export const UserBalanceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserBalanceApiAxiosParamCreator(configuration)
    return {
        /**
         * This method is used for fetching `UserBalance`
         * @summary Fetching `UserBalance`
         * @param {string} balance UserBalance identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userBalanceControllerGet(balance: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserBalanceGetResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userBalanceControllerGet(balance, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for fetching list of `UserBalances`
         * @summary Fetching list of `UserBalances`
         * @param {number} limit UserBalanceGetResponseDTO Items per page
         * @param {number} page UserBalanceGetResponseDTO Page to return
         * @param {'balance' | 'createdAt' | 'updatedAt'} orderBy UserBalance order field
         * @param {'asc' | 'desc'} orderDirection UserBalance order direction
         * @param {'crypto' | 'fiat'} [type] UserBalance currency type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userBalanceControllerGetList(limit: number, page: number, orderBy: 'balance' | 'createdAt' | 'updatedAt', orderDirection: 'asc' | 'desc', type?: 'crypto' | 'fiat', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserBalanceGetListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userBalanceControllerGetList(limit, page, orderBy, orderDirection, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserBalanceApi - factory interface
 * @export
 */
export const UserBalanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserBalanceApiFp(configuration)
    return {
        /**
         * This method is used for fetching `UserBalance`
         * @summary Fetching `UserBalance`
         * @param {string} balance UserBalance identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBalanceControllerGet(balance: string, options?: any): AxiosPromise<UserBalanceGetResponseDTO> {
            return localVarFp.userBalanceControllerGet(balance, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for fetching list of `UserBalances`
         * @summary Fetching list of `UserBalances`
         * @param {number} limit UserBalanceGetResponseDTO Items per page
         * @param {number} page UserBalanceGetResponseDTO Page to return
         * @param {'balance' | 'createdAt' | 'updatedAt'} orderBy UserBalance order field
         * @param {'asc' | 'desc'} orderDirection UserBalance order direction
         * @param {'crypto' | 'fiat'} [type] UserBalance currency type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBalanceControllerGetList(limit: number, page: number, orderBy: 'balance' | 'createdAt' | 'updatedAt', orderDirection: 'asc' | 'desc', type?: 'crypto' | 'fiat', options?: any): AxiosPromise<UserBalanceGetListResponseDTO> {
            return localVarFp.userBalanceControllerGetList(limit, page, orderBy, orderDirection, type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserBalanceApi - object-oriented interface
 * @export
 * @class UserBalanceApi
 * @extends {BaseAPI}
 */
export class UserBalanceApi extends BaseAPI {
    /**
     * This method is used for fetching `UserBalance`
     * @summary Fetching `UserBalance`
     * @param {string} balance UserBalance identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserBalanceApi
     */
    public userBalanceControllerGet(balance: string, options?: AxiosRequestConfig) {
        return UserBalanceApiFp(this.configuration).userBalanceControllerGet(balance, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for fetching list of `UserBalances`
     * @summary Fetching list of `UserBalances`
     * @param {number} limit UserBalanceGetResponseDTO Items per page
     * @param {number} page UserBalanceGetResponseDTO Page to return
     * @param {'balance' | 'createdAt' | 'updatedAt'} orderBy UserBalance order field
     * @param {'asc' | 'desc'} orderDirection UserBalance order direction
     * @param {'crypto' | 'fiat'} [type] UserBalance currency type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserBalanceApi
     */
    public userBalanceControllerGetList(limit: number, page: number, orderBy: 'balance' | 'createdAt' | 'updatedAt', orderDirection: 'asc' | 'desc', type?: 'crypto' | 'fiat', options?: AxiosRequestConfig) {
        return UserBalanceApiFp(this.configuration).userBalanceControllerGetList(limit, page, orderBy, orderDirection, type, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserBalanceLogApi - axios parameter creator
 * @export
 */
export const UserBalanceLogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This method is used for fetching `UserBalanceLog`
         * @summary Fetching `UserBalanceLog`
         * @param {string} balance UserBalance identifier
         * @param {string} log UserBalanceLog identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBalanceLogControllerGet: async (balance: string, log: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'balance' is not null or undefined
            assertParamExists('userBalanceLogControllerGet', 'balance', balance)
            // verify required parameter 'log' is not null or undefined
            assertParamExists('userBalanceLogControllerGet', 'log', log)
            const localVarPath = `/v1/user/balance/{balance}/log/{log}`
                .replace(`{${"balance"}}`, encodeURIComponent(String(balance)))
                .replace(`{${"log"}}`, encodeURIComponent(String(log)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used for fetching list of `UserBalanceLogs`
         * @summary Fetching list of `UserBalanceLogs`
         * @param {number} limit UserBalanceLogGetResponseDTO Items per page
         * @param {number} page UserBalanceLogGetResponseDTO Page to return
         * @param {string} balance UserBalance identifier
         * @param {string} [dateFrom] UserBalance from date
         * @param {string} [dateTo] UserBalance from date
         * @param {'asc' | 'desc'} [order] UserBalanceLog Order direction
         * @param {'deposit' | 'transfer'} [type] UserBalanceLog Operation type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBalanceLogControllerGetList: async (limit: number, page: number, balance: string, dateFrom?: string, dateTo?: string, order?: 'asc' | 'desc', type?: 'deposit' | 'transfer', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('userBalanceLogControllerGetList', 'limit', limit)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('userBalanceLogControllerGetList', 'page', page)
            // verify required parameter 'balance' is not null or undefined
            assertParamExists('userBalanceLogControllerGetList', 'balance', balance)
            const localVarPath = `/v1/user/balance/{balance}/log`
                .replace(`{${"balance"}}`, encodeURIComponent(String(balance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication userAuthorization required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString() :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString() :
                    dateTo;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserBalanceLogApi - functional programming interface
 * @export
 */
export const UserBalanceLogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserBalanceLogApiAxiosParamCreator(configuration)
    return {
        /**
         * This method is used for fetching `UserBalanceLog`
         * @summary Fetching `UserBalanceLog`
         * @param {string} balance UserBalance identifier
         * @param {string} log UserBalanceLog identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userBalanceLogControllerGet(balance: string, log: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserBalanceLogGetResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userBalanceLogControllerGet(balance, log, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used for fetching list of `UserBalanceLogs`
         * @summary Fetching list of `UserBalanceLogs`
         * @param {number} limit UserBalanceLogGetResponseDTO Items per page
         * @param {number} page UserBalanceLogGetResponseDTO Page to return
         * @param {string} balance UserBalance identifier
         * @param {string} [dateFrom] UserBalance from date
         * @param {string} [dateTo] UserBalance from date
         * @param {'asc' | 'desc'} [order] UserBalanceLog Order direction
         * @param {'deposit' | 'transfer'} [type] UserBalanceLog Operation type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userBalanceLogControllerGetList(limit: number, page: number, balance: string, dateFrom?: string, dateTo?: string, order?: 'asc' | 'desc', type?: 'deposit' | 'transfer', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserBalanceLogGetListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userBalanceLogControllerGetList(limit, page, balance, dateFrom, dateTo, order, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserBalanceLogApi - factory interface
 * @export
 */
export const UserBalanceLogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserBalanceLogApiFp(configuration)
    return {
        /**
         * This method is used for fetching `UserBalanceLog`
         * @summary Fetching `UserBalanceLog`
         * @param {string} balance UserBalance identifier
         * @param {string} log UserBalanceLog identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBalanceLogControllerGet(balance: string, log: string, options?: any): AxiosPromise<UserBalanceLogGetResponseDTO> {
            return localVarFp.userBalanceLogControllerGet(balance, log, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used for fetching list of `UserBalanceLogs`
         * @summary Fetching list of `UserBalanceLogs`
         * @param {number} limit UserBalanceLogGetResponseDTO Items per page
         * @param {number} page UserBalanceLogGetResponseDTO Page to return
         * @param {string} balance UserBalance identifier
         * @param {string} [dateFrom] UserBalance from date
         * @param {string} [dateTo] UserBalance from date
         * @param {'asc' | 'desc'} [order] UserBalanceLog Order direction
         * @param {'deposit' | 'transfer'} [type] UserBalanceLog Operation type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBalanceLogControllerGetList(limit: number, page: number, balance: string, dateFrom?: string, dateTo?: string, order?: 'asc' | 'desc', type?: 'deposit' | 'transfer', options?: any): AxiosPromise<UserBalanceLogGetListResponseDTO> {
            return localVarFp.userBalanceLogControllerGetList(limit, page, balance, dateFrom, dateTo, order, type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserBalanceLogApi - object-oriented interface
 * @export
 * @class UserBalanceLogApi
 * @extends {BaseAPI}
 */
export class UserBalanceLogApi extends BaseAPI {
    /**
     * This method is used for fetching `UserBalanceLog`
     * @summary Fetching `UserBalanceLog`
     * @param {string} balance UserBalance identifier
     * @param {string} log UserBalanceLog identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserBalanceLogApi
     */
    public userBalanceLogControllerGet(balance: string, log: string, options?: AxiosRequestConfig) {
        return UserBalanceLogApiFp(this.configuration).userBalanceLogControllerGet(balance, log, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used for fetching list of `UserBalanceLogs`
     * @summary Fetching list of `UserBalanceLogs`
     * @param {number} limit UserBalanceLogGetResponseDTO Items per page
     * @param {number} page UserBalanceLogGetResponseDTO Page to return
     * @param {string} balance UserBalance identifier
     * @param {string} [dateFrom] UserBalance from date
     * @param {string} [dateTo] UserBalance from date
     * @param {'asc' | 'desc'} [order] UserBalanceLog Order direction
     * @param {'deposit' | 'transfer'} [type] UserBalanceLog Operation type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserBalanceLogApi
     */
    public userBalanceLogControllerGetList(limit: number, page: number, balance: string, dateFrom?: string, dateTo?: string, order?: 'asc' | 'desc', type?: 'deposit' | 'transfer', options?: AxiosRequestConfig) {
        return UserBalanceLogApiFp(this.configuration).userBalanceLogControllerGetList(limit, page, balance, dateFrom, dateTo, order, type, options).then((request) => request(this.axios, this.basePath));
    }
}


